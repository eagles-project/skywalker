{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Skywalker is a software library that allows you to construct and execute a program on an ensemble : a collection of sets of input parameters, each of which completely defines the behavior of the program. Each complete set of input parameters is a member of the ensemble, and your program can associate a set of outputs with each ensemble member. A Skywalker program accepts as input a YAML file that defines an ensemble. It then executes logic on each member of that ensemble, generating output. It collects this output, associating it with the input that produced it, and then writes all data for the entire ensemble into a Python module in a way that allows postprocessing to be easily performed. You can write a Skywalker program in C, C++, or Fortran. The code you'll write looks very similar in each of these languages. Here are some resources for you to use to solve your own problems with a Skywalker program: The Installation guide shows you how to build and install Skywalker. The Quick Start guide shows you how to write a basic Skywalker program. The API guide describes Skywalker's application programming interface for all three languages. We've provided a detailed example that demonstrates how you can use Skywalker to investigate a problem. Acknowledgements Skywalker was developed as part of a close collaboration between climate scientists and software engineers as part of an effort to cross validate two implementations of an aerosol microphysics box model. This effort was funded by the Office of Science's Biological and Environmental Research Program as part of the EAGLES project , an effort to improve the treatment of aerosols in E3SM , the Department of Energy's global climate model. The source code is available on GitHub .","title":"Overview"},{"location":"#overview","text":"Skywalker is a software library that allows you to construct and execute a program on an ensemble : a collection of sets of input parameters, each of which completely defines the behavior of the program. Each complete set of input parameters is a member of the ensemble, and your program can associate a set of outputs with each ensemble member. A Skywalker program accepts as input a YAML file that defines an ensemble. It then executes logic on each member of that ensemble, generating output. It collects this output, associating it with the input that produced it, and then writes all data for the entire ensemble into a Python module in a way that allows postprocessing to be easily performed. You can write a Skywalker program in C, C++, or Fortran. The code you'll write looks very similar in each of these languages. Here are some resources for you to use to solve your own problems with a Skywalker program: The Installation guide shows you how to build and install Skywalker. The Quick Start guide shows you how to write a basic Skywalker program. The API guide describes Skywalker's application programming interface for all three languages. We've provided a detailed example that demonstrates how you can use Skywalker to investigate a problem.","title":"Overview"},{"location":"#acknowledgements","text":"Skywalker was developed as part of a close collaboration between climate scientists and software engineers as part of an effort to cross validate two implementations of an aerosol microphysics box model. This effort was funded by the Office of Science's Biological and Environmental Research Program as part of the EAGLES project , an effort to improve the treatment of aerosols in E3SM , the Department of Energy's global climate model. The source code is available on GitHub .","title":"Acknowledgements"},{"location":"api/","text":"The Skywalker API Skywalker offers a simple interface for writing programs that operate on entire ensembles. You can access everything in this interface by including the correct C/C++ header file or using the appropriate Fortran module in your program. C C++ Fortran #include <skywalker.h> #include <skywalker.hpp> use skywalker Skywalker is written in C, and the C interface is the source of truth for the Fortran and C++ bindings. The Fortran skywalker module exposes all the same types and functions as the C interface. The C++ interface wraps all of the C types in a skywalker.hpp header file, exposing then in the skywalker namespace. A Skywalker program typically consists of the following parts: Ensemble and settings information are loaded from an input YAML file Settings are used to configure the program to run the loaded ensemble One by one, ensemble members are processed by the program. Ensemble input parameters are retrieved and used to run a simulation, and then ensemble output parameters are written and stored. The resulting ensemble is written to a Python module. All input and output parameters are written and stored in a way that allows them to be programmatically accessed by a postprocessing script. Here we describe the types and functions you can use to assemble your own Skywalker program. Data Types Real number type Skywalker supports exactly one value type that stores real-valued ensemble parameters. By default this type is a double-precision floating point number, but it can be configured for single precision with the SKYWALKER_PRECISION CMake variable. C C++ Fortran typedef double sw_real_t ; using Real = sw_real_t ; ! Skywalker precision (swp): real kind used by skywalker integer , parameter :: swp In Fortran, the swp kind is used to store input parameters and output values, and is set to either the c_double or c_float interoperable types defined by the Fortran 2003 ISO C bindings. The C interface also defines the following macros: SW_EPSILON : the \"machine epsilon\" value, an upper bound on the relative relative approximation error due to rounding in floating point arithmetic. This maps either to FLT_EPSILON or DBL_EPSILON as defined in float.h , depending on Skywalker's precision. SW_MIN : the minimum representable floating point number. Maps to FLT_MIN or DBL_MIN as defined in float.h . SW_MAX : the maximum representable floating point number. Maps to FLT_MAX or DBL_MAX as defined in float.h . Interface types Each of the essential concepts in the library has an associated type. An Ensemble stores a set of input and output data for each of its members. C C++ Fortran typedef struct sw_ensemble_t sw_ensemble_t ; class Ensemble final { public : // Returns the settings associated with this ensemble. const Settings & settings () const ; // Iterates over all ensemble members, applying the given function f to // each input/output pair. void process ( std :: function < void ( const Input & , Output & ) > f ); // Returns the size of the ensemble (number of members). size_t size () const ; // Writes input and output data within the ensemble to a Python module stored // in the file with the given name. void write ( const std :: string & module_filename ) const ; }; type :: ensemble_t type ( c_ptr ) :: ptr integer ( c_size_t ) :: size ! number of members contains ! Iterates over ensemble members procedure :: next => ensemble_next ! Writes a Python module containing input/output data to a file, halting ! on failure procedure :: write => ensemble_write ! Writes a Python module containing input/output data to a file procedure :: write_module => ensemble_write_module ! Destroys an ensemble, freeing all allocated resources. Use at the end of ! a driver program, or when a fatal error has occurred. procedure :: free => ensemble_free end type ensemble_t The Settings type stores configuration data or metadata associated with your program and how it treats ensemble members. All of these data are strings that can be retrieved by name. C C++ Fortran typedef struct sw_settings_t sw_settings_t ; class Settings final { public : // Returns true if the setting with the given name exists within the given // settings instance, false otherwise. bool has ( const std :: string & name ) const ; // Retrieves a (string-valued) setting with the given name, throwing an // exception if it doesn't exist. std :: string get ( const std :: string & name ) const ; }; type :: settings_t type ( c_ptr ) :: ptr , ensemble_ptr contains procedure :: has => settings_has procedure :: get => settings_get procedure :: get_param => settings_get_param end type Ensemble member input is stored in a set of named ensemble parameters within a dedicated type. Input data cannot be modified--it can only be read. C C++ Fortran typedef struct sw_input_t sw_input_t ; class Input final { public : Input (); // Returns true if the input parameter with the given name exists within // the given input instance, false otherwise. bool has ( const std :: string & name ) const ; // Retrieves a (real-valued) parameter with the given name, throwing an // exception if it doesn't exist. Real get ( const std :: string & name ) const ; // Returns true if an input array parameter with the given name exists // within the given input instance, false otherwise. bool has_array ( const std :: string & name ) const ; // Retrieves a (real-valued) array parameter with the given name, throwing // an exception if it doesn't exist. std :: vector < Real > get_array ( const std :: string & name ) const ; }; type :: input_t type ( c_ptr ) :: ptr , ensemble_ptr contains procedure :: has => input_has procedure :: get => input_get procedure :: get_param => input_get_param procedure :: has_array => input_has_array procedure :: get_array => input_get_array procedure :: get_array_param => input_get_array_param end type input_t Ensemble member output is also stored in a set of named ensemble parameters within a dedicated type. Unlike input data, output ensemble parameters can only be written. C C++ Fortran typedef struct sw_output_t sw_output_t ; class Output final { public : Output (); // Sets a (real-valued) parameter with the given name, throwing an // exception if not successful. void set ( const std :: string & name , Real value ) const ; // Sets (real-valued) parameters with the given name, throwing an // exception if not successful. void set ( const std :: string & name , const std :: vector < Real > & values ) const ; }; type :: output_t type ( c_ptr ) :: ptr contains ! Adds a named metric to the output data. procedure :: set => output_set ! Adds a vector of named metric to the output data. procedure :: set_array => output_set_array end type output_t Notice that many of the Fortran types are actually classes with bound procedures with implementations, indicated by the procedure => implementation \u0455yntax. Below, we refer to the functions and subroutines that implement the procedures. The examples and tests illustrate how these procedures are invoked, as this syntax is unfortunately not very clear. Result types The C and Fortran interfaces define types that store the results of operations like loading ensembles from input, fetching input parameters, and writing output parameters. These \"result\" types contain information that can be used for handling errors, and each type has result_t at the end of its name. Error Handling The types in Skywalker's C interface contain fields that can be used to properly handle any errors that occur while reading input or constructing ensembles: error_code : an integer that identifies a specific type of error that you can use to programmatically handle error conditions. The integer can be compared with the fields in the sw_error_code_t enumerated type in skywalker.h or the integer parameters defined in the Fortran module. error_message : a descriptive error string that can be printed to tell a user what went wrong The Fortran interface offers similar result types with these same fields, but also offers \"shorthand\" versions of functions that simply halt the program with the Fortran STOP command when an error occurs. The C++ interface does not define types to store the results of its functions. Instead, it directly returns the data requested, throwing an exception (of type skywalker::Exception , a subclass of std::exception ) containing a string description if any issue occurs. The examples and tests in the repository demonstrate how these error handling mechanisms work in their respective languages. Loading an Ensemble and Settings You can load an ensemble and settings for your program from a YAML input file with a single function call. C C++ Fortran sw_ensemble_result_t sw_load_ensemble ( const char * yaml_file , const char * settings_block ); namespace skywalker { Ensemble * load_ensemble ( const std :: string & yaml_file , const std :: string & settings_block = \"\" ); } function load_ensemble ( yaml_file , settings_block ) result ( e_result ) character ( len =* ), intent ( in ) :: yaml_file character ( len =* ), intent ( in ), optional :: settings_block type ( ensemble_result_t ) :: e_result end function yaml_file is the name of the YAML input file to be read. It can be an absolute or relative path to a file on disk. settings_block is the name of the block in the YAML file from which settings are read. This can be the name of your program, or just \"settings\" if you want a mneumonic name. This argument is optional: If this string is NULL or blank in C, or not given in C++ or Fortran, Skywalker does not attempt to read any settings from the file. Settings can be used to create a single YAML input file that defines ensembles for several Skywalker programs (e.g. for cross validating different methods or models). Each program can define its own settings in a program-specific block whose name is indicated using the settings_block parameter. The C and Fortran interfaces return a result that contains the ensemble and settings, as well as error handling information. C Fortran typedef struct sw_ensemble_result_t { // The settings associated with the driver program sw_settings_t * settings ; // The ensemble loaded (or NULL on failure) sw_ensemble_t * ensemble ; // An error code indicating any problems encountered loading the ensemble // (zero = success, non-zero = failure) int error_code ; // A string describing any error encountered, or NULL if error_code == 0. const char * error_message ; } sw_ensemble_result_t ; type :: ensemble_result_t ! The settings associated with the driver program type ( settings_t ) :: settings ! The ensemble loaded (if no error occurred) type ( ensemble_t ) :: ensemble ! The ensemble's type integer :: type ! An error code indicating any problems encountered loading the ensemble ! (zero = success, non-zero = failure) integer :: error_code ! A string describing any error encountered, or NULL if error_code == 0. character ( len = 255 ) :: error_message end type ensemble_result_t The C++ interface returns a pointer to an Ensemble instance. Settings are available within this instance. If an error occurs, a skywalker::Exception is thrown containing an error message string identical to the error_message field of the result type returned by the C and Fortran interfaces. Applying Program Settings If your program can run in more than one configuration, you can select a configuration using the data specified in the settings you've loaded. Settings are stored in strings, and you can retrieve a setting by name from the settings variable you've loaded. Settings can be queried with a has function that returns true if a setting with the given name is found and false otherwise. C C++ Fortran // Returns true if the setting with the given name exists within the given // settings instance, false otherwise. bool sw_settings_has ( sw_settings_t * settings , const char * name ); class Settings final { ... // Returns true if the setting with the given name exists within the given // settings instance, false otherwise. bool has ( const std :: string & name ) const ; ... }; ! Returns .true. if the setting with the given name exists within the given ! settings instance, false otherwise. function settings_has ( settings , name ) result ( has ) class ( settings_t ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: name logical ( c_bool ) :: has end function A setting with the given name can be fetched. C C++ Fortran // Retrieves the setting with the given name. sw_settings_result_t sw_settings_get ( sw_settings_t * settings , const char * name ); class Settings final { ... // Retrieves a (string-valued) setting with the given name, throwing an // exception if it doesn't exist. std :: string get ( const std :: string & name ) const { ... }; ! Retrieves the setting with the given name, returning a result that can ! be checked for errors that occur. function settings_get_param ( settings , name ) result ( s_result ) class ( settings_t ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: name type ( settings_result_t ) :: s_result end function Fetching a setting fails if a setting with the given name doesn't exist. The C and Fortran interfaces define a result type that allows this situation to be handled. C Fortran typedef struct sw_setting_result_t { const char * value ; // fetched value (if error_code == 0) int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_settings_result_t ; type :: settings_result_t character ( len = 255 ) :: value ! fetched value (if error_code == 0) integer :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type settings_result_t On failure, the C++ interface throws a skywalker::Exception with a string description identical to the error_message description in the C and Fortran result types. For brevity, the Fortran interface also offers a function that halts your program if a setting is not found: Fortran ! Retrieves the setting with the given name, halting the program if an ! error occurs. function settings_get ( settings , name ) result ( str ) class ( settings_t ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: name character ( len = 255 ) :: str end function Processing an Ensemble Member The bulk of your Skywalker program is concerned with processing each member of an ensemble. To do this, you must loop over the ensemble, retrieving the input and output variables for each member read input parameters from the member's input variable use the input parameters to compute output. set the output parameters in the member's output variable Looping over ensemble members Skywalker handles the process of looping over the ensemble for you. In C and Fortran, you can construct a loop that calls a function to get the input and output parameters for each member, terminating when there are no members left. C Fortran // Iterates over the inputs and outputs in an ensemble, making them available // one at a time for computation. This function returns true once for each // member of an ensemble and false once the ensemble's members have been // traversed. Use it as a predicate in a while loop in which inputs and outputs // are processed. bool sw_ensemble_next ( sw_ensemble_t * ensemble , sw_input_t ** input , sw_output_t ** output ); ! Iterates over the inputs and outputs in an ensemble, making them available ! one at a time for computation. This function returns true once for each ! member of an ensemble and false once the ensemble's members have been ! traversed. Use it as a predicate in a do while loop in which inputs and ! outputs are processed. function ensemble_next ( ensemble , input , output ) result ( next ) class ( ensemble_t ), intent ( in ) :: ensemble type ( input_t ), intent ( out ) :: input type ( output_t ), intent ( out ) :: output logical ( c_bool ) :: next end function In C++, you can write your own function that performs the processing, and pass that function to a method on your Ensemble object. This executes your function on the input and output data for each member. The function you define takes a const reference to an Input object and a non- const reference to an Output object, and returns nothing. C++ class Ensemble final { ... // Iterates over all ensemble members, applying the given function f to // each input/output pair. void process ( std :: function < void ( const Input & , Output & ) > f ); ... }; The examples and tests illustrate how this is done. Reading input parameters To read an input parameter from an ensemble member, you can retrieve its value using its name. It's easy to check whether the ensemble member has a given parameter: C C++ Fortran // Returns true if a (scalar) input parameter with the given name exists // within the given input instance, false otherwise. bool sw_input_has ( sw_input_t * input , const char * name ); class Input final { ... // Returns true if the input parameter with the given name exists within // the given input instance, false otherwise. bool has ( const std :: string & name ) const ; ... }; ! Returns .true. if the input parameter with the given name exists within the ! given input instance, false otherwise. function input_has ( input , name ) result ( has ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name logical ( c_bool ) :: has end function Similarly, it's easy to fetch the parameter: C C++ Fortran // Retrieves the (scalar) input parameter with the given name. sw_input_result_t sw_input_get ( sw_input_t * input , const char * name ); class Input final { ... // Retrieves a (real-valued) parameter with the given name, throwing an // exception if it doesn't exist. Real get ( const std :: string & name ) const ; ... }; ! Retrieves the input parameter with the given name. function input_get_param ( input , name ) result ( i_result ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name type ( input_result_t ) :: i_result end function Fetching a parameter fails if the parameter doesn't exist within the ensemble. The C and Fortran interfaces return a result type that allows you to check whether the operation succeeded. C Fortran typedef struct sw_input_result_t { sw_real_t value ; // fetched value (if error_code == 0) int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_input_result_t ; type :: input_result_t real ( c_real ) :: value ! fetched value (if error_code == 0) integer ( c_int ) :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type input_result_t In C++, a skywalker::Exception is thrown in the case of failure, with an error string identical to the error_message field of the corresponding C and Fortran result types. The Fortran interface also offers you a \"shortcut\" that directly fetches your input parameter, halting your program with STOP on failure. Fortran ! Retrieves the input parameter with the given name, halting the program ! on failure. function input_get ( input , name ) result ( val ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name real ( c_real ) :: val end function Reading input array parameters Skywalker offers you the ability to work with arrays of real-valued input parameters identified by a single name. These array parameters work the same as their scalar counterparts. Their memory is managed by Skywalker, so there's no need for you to perform any memory allocation. As with scalar input parameters, you can check to see whether an input array parameter exists within an ensemble member. C C++ Fortran // Returns true if an input array parameter with the given name exists within // the given input instance, false otherwise. bool sw_input_has_array ( sw_input_t * input , const char * name ); class Input final { ... // Returns true if an input array parameter with the given name exists within // the given input instance, false otherwise. bool has_array ( const std :: string & name ) const ; ... }; ! Returns .true. if an input array parameter with the given name exists within ! the given input instance, false otherwise. function input_has_array ( input , name ) result ( has ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name logical ( c_bool ) :: has end function The process of retrieving input array parameters works the same way as it does for scalar input parameters. C C++ Fortran // Retrieves the (array-valued) input parameter with the given name. sw_input_array_result_t sw_input_get_array ( sw_input_t * input , const char * name ); class Input final { ... // Retrieves a (real-valued) array parameter with the given name, throwing an // exception if it doesn't exist. std :: vector < Real > get_array ( const std :: string & name ) const ; }; ! Retrieves the input array parameter with the given name. function input_get_array_param ( input , name ) result ( i_result ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name type ( input_array_result_t ) :: i_result end function The C and Fortran interface define result types for fetching input array parameters. C Fortran typedef struct sw_input_array_result_t { sw_real_t * values ; // fetched values (if error_code == 0) size_t size ; // number of values (if error_code == 0) int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_input_array_result_t ; type :: input_array_result_t real ( c_real ), dimension (:), pointer :: values ! fetched values (if error_code == 0) integer ( c_size_t ) :: size ! number of values (if error_code == 0) integer ( c_int ) :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type input_array_result_t As with scalar input parameters, the C++ interface throws a skywalker::Exception if it cannot retrieve a given input array parameter. And, as in the scalar case, the Fortran interface also defines a subroutine that tries to fetch an array parameter and halts with STOP on failure. Fortran ! Retrieves the input array parameter with the given name, halting on ! failure. subroutine input_get_array ( input , name , values ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name real ( c_real ), allocatable , dimension (:), intent ( inout ) :: values end subroutine If you use this subroutine, you must deallocate the values array when you're finished with it. Computing output parameters from input parameters This is where you do your thing. Nobody knows your job better than you! Remember that all input and output parameters are floating point numbers, so if your work uses integer inputs or outputs, you must perform all necessary type casting. Setting output parameters When you've computed an output value from one or more input values, you'll want to store that value by name in the ensemble member's output data. To do this, you can call a function to set the value of a named output parameter. C C++ Fortran // This function sets a quantity with the given name and value within the given // output instance. This operation cannot fail under normal circumstances. void sw_output_set ( sw_output_t * output , const char * name , sw_real_t value ); class Output final { ... // Sets a (real-valued) parameter with the given name. This operation // cannot fail under normal circumstances. void set ( const std :: string & name , Real value ) const ; ... }; ! Sets a quantity with the given name and value within the given output ! instance. This operation cannot fail under normal circumstances. subroutine output_set ( output , name , value ) class ( output_t ), intent ( in ) :: output character ( len =* ), intent ( in ) :: name real ( c_real ), intent ( in ) :: value end subroutine The operation of setting an output parameter can't fail under normal circumstances (sufficient memory, good hardware, etc). Skywalker handles all the bookkeeping details. Setting output array parameters Output array parameters work the same way as input array parameters: they're just output values that share a common name. You can set an array-valued output parameter by calling the appropriate function or subroutine. C C++ Fortran // This function sets an array of quantities with the given name and values // within the given output instance. This operation cannot fail under normal // circumstances. void sw_output_set_array ( sw_output_t * output , const char * name , const sw_real_t * values , size_t size ); class Output final { ... // Sets (real-valued) parameters in an array with the given name. This // operation cannot fail under normal circumstances. void set ( const std :: string & name , const std :: vector < Real > & values ) const ; ... }; ! Sets an array of quantities with the given name and values to the given ! output instance. This operation cannot fail under normal circumstances. subroutine output_set_array ( output , name , values ) class ( output_t ), intent ( in ) :: output character ( len =* ), intent ( in ) :: name real ( c_real ), target , intent ( in ), dimension (:) :: values end subroutine As with scalar output parameters, the operation of setting an output array parameter cannot fail under normal circumstances. Writing Ensemble Output At the end of your program, you can call a function to write all your ensemble data to a Python module that be postprocessed. C C++ Fortran // Writes input and output data within the ensemble to a Python module stored // in the file with the given name. sw_write_result_t sw_ensemble_write ( sw_ensemble_t * ensemble , const char * module_filename ); class Ensemble final { ... // Writes input and output data within the ensemble to a Python module stored // in the file with the given name. void write ( const std :: string & module_filename ) const ; ... }; ! Writes input and output data within the ensemble to a Python module stored ! in the file with the given name. function ensemble_write_module ( ensemble , module_filename ) result ( w_result ) class ( ensemble_t ), intent ( in ) :: ensemble character ( len =* ), intent ( in ) :: module_filename type ( write_result_t ) :: w_result end subroutine Because it attempts to write a file, this operation can fail. The C and Fortran interfaces define a result type that can capture the information needed to handle this failure. C Fortran typedef struct sw_write_result_t { int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_write_result_t ; type :: write_result_t integer ( c_int ) :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type write_result_t As usual, the C++ interface throws a skywalker::Exception containing a string identical to the error_message field found in the corresponding C and Fortran result types. And, as usual, there is a Fortran subroutine that attempts to write the ensemble data to the given file and halts on failure. Fortran ! Writes input and output data within the ensemble to a Python module stored ! in the file with the given name, halting on failure. subroutine ensemble_write ( ensemble , module_filename ) class ( ensemble_t ), intent ( in ) :: ensemble character ( len =* ), intent ( in ) :: module_filename end subroutine Cleanup After you've written the Python module, you should free the resources your ensemble uses by destroying it. In C and Fortran, you can do this with a simple function call. C Fortran // Destroys an ensemble, freeing its allocated resources. Use this at the end // of your driver program, or when a fatal error has been encountered. void sw_ensemble_free ( sw_ensemble_t * ensemble ); ! Destroys an ensemble, freeing all allocated resources. subroutine ensemble_free ( ensemble ) class ( ensemble_t ), intent ( in ) :: ensemble end subroutine In C++, you can simply delete the Ensemble pointer you obtained by calling skywalker::load_ensemble , or you can use a smart pointer to store the ensemble. Miscellaneous In addition to the types and interfaces we've described, there are a few extra functions you might find handy in your Skywalker program. Printing a banner You can write a banner to the standard error strstream ( stderr in C and C++) with a call to the appropriate function. C C++ Fortran // Prints a banner containing Skywalker's version info to stderr. void sw_print_banner ( void ); namespace skywalker { ... // Prints a banner containing Skywalker's version info to stderr. void print_banner () { ... } // namespace skywalker ! Prints a banner containing Skywalker's version info to stderr. subroutine print_banner () end subroutine This banner prints out the version of Skywalker used by your program. This can be helpful if you think you've encountered a bug in Skywalker, or if you're trying to use a newer feature of the library. Getting the ensemble's size Sometimes it helps to know how many members an ensemble contains. C C++ Fortran // Returns the size of the given ensemble. size_t sw_ensemble_size ( sw_ensemble_t * ensemble ); class Ensemble { ... // Returns the size of the ensemble (number of members). size_t size () const ; ... }; The ensemble's size is stored in the size field of the ensemble_t derived type.","title":"The Skywalker API"},{"location":"api/#the-skywalker-api","text":"Skywalker offers a simple interface for writing programs that operate on entire ensembles. You can access everything in this interface by including the correct C/C++ header file or using the appropriate Fortran module in your program. C C++ Fortran #include <skywalker.h> #include <skywalker.hpp> use skywalker Skywalker is written in C, and the C interface is the source of truth for the Fortran and C++ bindings. The Fortran skywalker module exposes all the same types and functions as the C interface. The C++ interface wraps all of the C types in a skywalker.hpp header file, exposing then in the skywalker namespace. A Skywalker program typically consists of the following parts: Ensemble and settings information are loaded from an input YAML file Settings are used to configure the program to run the loaded ensemble One by one, ensemble members are processed by the program. Ensemble input parameters are retrieved and used to run a simulation, and then ensemble output parameters are written and stored. The resulting ensemble is written to a Python module. All input and output parameters are written and stored in a way that allows them to be programmatically accessed by a postprocessing script. Here we describe the types and functions you can use to assemble your own Skywalker program.","title":"The Skywalker API"},{"location":"api/#data-types","text":"","title":"Data Types"},{"location":"api/#real-number-type","text":"Skywalker supports exactly one value type that stores real-valued ensemble parameters. By default this type is a double-precision floating point number, but it can be configured for single precision with the SKYWALKER_PRECISION CMake variable. C C++ Fortran typedef double sw_real_t ; using Real = sw_real_t ; ! Skywalker precision (swp): real kind used by skywalker integer , parameter :: swp In Fortran, the swp kind is used to store input parameters and output values, and is set to either the c_double or c_float interoperable types defined by the Fortran 2003 ISO C bindings. The C interface also defines the following macros: SW_EPSILON : the \"machine epsilon\" value, an upper bound on the relative relative approximation error due to rounding in floating point arithmetic. This maps either to FLT_EPSILON or DBL_EPSILON as defined in float.h , depending on Skywalker's precision. SW_MIN : the minimum representable floating point number. Maps to FLT_MIN or DBL_MIN as defined in float.h . SW_MAX : the maximum representable floating point number. Maps to FLT_MAX or DBL_MAX as defined in float.h .","title":"Real number type"},{"location":"api/#interface-types","text":"Each of the essential concepts in the library has an associated type. An Ensemble stores a set of input and output data for each of its members. C C++ Fortran typedef struct sw_ensemble_t sw_ensemble_t ; class Ensemble final { public : // Returns the settings associated with this ensemble. const Settings & settings () const ; // Iterates over all ensemble members, applying the given function f to // each input/output pair. void process ( std :: function < void ( const Input & , Output & ) > f ); // Returns the size of the ensemble (number of members). size_t size () const ; // Writes input and output data within the ensemble to a Python module stored // in the file with the given name. void write ( const std :: string & module_filename ) const ; }; type :: ensemble_t type ( c_ptr ) :: ptr integer ( c_size_t ) :: size ! number of members contains ! Iterates over ensemble members procedure :: next => ensemble_next ! Writes a Python module containing input/output data to a file, halting ! on failure procedure :: write => ensemble_write ! Writes a Python module containing input/output data to a file procedure :: write_module => ensemble_write_module ! Destroys an ensemble, freeing all allocated resources. Use at the end of ! a driver program, or when a fatal error has occurred. procedure :: free => ensemble_free end type ensemble_t The Settings type stores configuration data or metadata associated with your program and how it treats ensemble members. All of these data are strings that can be retrieved by name. C C++ Fortran typedef struct sw_settings_t sw_settings_t ; class Settings final { public : // Returns true if the setting with the given name exists within the given // settings instance, false otherwise. bool has ( const std :: string & name ) const ; // Retrieves a (string-valued) setting with the given name, throwing an // exception if it doesn't exist. std :: string get ( const std :: string & name ) const ; }; type :: settings_t type ( c_ptr ) :: ptr , ensemble_ptr contains procedure :: has => settings_has procedure :: get => settings_get procedure :: get_param => settings_get_param end type Ensemble member input is stored in a set of named ensemble parameters within a dedicated type. Input data cannot be modified--it can only be read. C C++ Fortran typedef struct sw_input_t sw_input_t ; class Input final { public : Input (); // Returns true if the input parameter with the given name exists within // the given input instance, false otherwise. bool has ( const std :: string & name ) const ; // Retrieves a (real-valued) parameter with the given name, throwing an // exception if it doesn't exist. Real get ( const std :: string & name ) const ; // Returns true if an input array parameter with the given name exists // within the given input instance, false otherwise. bool has_array ( const std :: string & name ) const ; // Retrieves a (real-valued) array parameter with the given name, throwing // an exception if it doesn't exist. std :: vector < Real > get_array ( const std :: string & name ) const ; }; type :: input_t type ( c_ptr ) :: ptr , ensemble_ptr contains procedure :: has => input_has procedure :: get => input_get procedure :: get_param => input_get_param procedure :: has_array => input_has_array procedure :: get_array => input_get_array procedure :: get_array_param => input_get_array_param end type input_t Ensemble member output is also stored in a set of named ensemble parameters within a dedicated type. Unlike input data, output ensemble parameters can only be written. C C++ Fortran typedef struct sw_output_t sw_output_t ; class Output final { public : Output (); // Sets a (real-valued) parameter with the given name, throwing an // exception if not successful. void set ( const std :: string & name , Real value ) const ; // Sets (real-valued) parameters with the given name, throwing an // exception if not successful. void set ( const std :: string & name , const std :: vector < Real > & values ) const ; }; type :: output_t type ( c_ptr ) :: ptr contains ! Adds a named metric to the output data. procedure :: set => output_set ! Adds a vector of named metric to the output data. procedure :: set_array => output_set_array end type output_t Notice that many of the Fortran types are actually classes with bound procedures with implementations, indicated by the procedure => implementation \u0455yntax. Below, we refer to the functions and subroutines that implement the procedures. The examples and tests illustrate how these procedures are invoked, as this syntax is unfortunately not very clear.","title":"Interface types"},{"location":"api/#result-types","text":"The C and Fortran interfaces define types that store the results of operations like loading ensembles from input, fetching input parameters, and writing output parameters. These \"result\" types contain information that can be used for handling errors, and each type has result_t at the end of its name.","title":"Result types"},{"location":"api/#error-handling","text":"The types in Skywalker's C interface contain fields that can be used to properly handle any errors that occur while reading input or constructing ensembles: error_code : an integer that identifies a specific type of error that you can use to programmatically handle error conditions. The integer can be compared with the fields in the sw_error_code_t enumerated type in skywalker.h or the integer parameters defined in the Fortran module. error_message : a descriptive error string that can be printed to tell a user what went wrong The Fortran interface offers similar result types with these same fields, but also offers \"shorthand\" versions of functions that simply halt the program with the Fortran STOP command when an error occurs. The C++ interface does not define types to store the results of its functions. Instead, it directly returns the data requested, throwing an exception (of type skywalker::Exception , a subclass of std::exception ) containing a string description if any issue occurs. The examples and tests in the repository demonstrate how these error handling mechanisms work in their respective languages.","title":"Error Handling"},{"location":"api/#loading-an-ensemble-and-settings","text":"You can load an ensemble and settings for your program from a YAML input file with a single function call. C C++ Fortran sw_ensemble_result_t sw_load_ensemble ( const char * yaml_file , const char * settings_block ); namespace skywalker { Ensemble * load_ensemble ( const std :: string & yaml_file , const std :: string & settings_block = \"\" ); } function load_ensemble ( yaml_file , settings_block ) result ( e_result ) character ( len =* ), intent ( in ) :: yaml_file character ( len =* ), intent ( in ), optional :: settings_block type ( ensemble_result_t ) :: e_result end function yaml_file is the name of the YAML input file to be read. It can be an absolute or relative path to a file on disk. settings_block is the name of the block in the YAML file from which settings are read. This can be the name of your program, or just \"settings\" if you want a mneumonic name. This argument is optional: If this string is NULL or blank in C, or not given in C++ or Fortran, Skywalker does not attempt to read any settings from the file. Settings can be used to create a single YAML input file that defines ensembles for several Skywalker programs (e.g. for cross validating different methods or models). Each program can define its own settings in a program-specific block whose name is indicated using the settings_block parameter. The C and Fortran interfaces return a result that contains the ensemble and settings, as well as error handling information. C Fortran typedef struct sw_ensemble_result_t { // The settings associated with the driver program sw_settings_t * settings ; // The ensemble loaded (or NULL on failure) sw_ensemble_t * ensemble ; // An error code indicating any problems encountered loading the ensemble // (zero = success, non-zero = failure) int error_code ; // A string describing any error encountered, or NULL if error_code == 0. const char * error_message ; } sw_ensemble_result_t ; type :: ensemble_result_t ! The settings associated with the driver program type ( settings_t ) :: settings ! The ensemble loaded (if no error occurred) type ( ensemble_t ) :: ensemble ! The ensemble's type integer :: type ! An error code indicating any problems encountered loading the ensemble ! (zero = success, non-zero = failure) integer :: error_code ! A string describing any error encountered, or NULL if error_code == 0. character ( len = 255 ) :: error_message end type ensemble_result_t The C++ interface returns a pointer to an Ensemble instance. Settings are available within this instance. If an error occurs, a skywalker::Exception is thrown containing an error message string identical to the error_message field of the result type returned by the C and Fortran interfaces.","title":"Loading an Ensemble and Settings"},{"location":"api/#applying-program-settings","text":"If your program can run in more than one configuration, you can select a configuration using the data specified in the settings you've loaded. Settings are stored in strings, and you can retrieve a setting by name from the settings variable you've loaded. Settings can be queried with a has function that returns true if a setting with the given name is found and false otherwise. C C++ Fortran // Returns true if the setting with the given name exists within the given // settings instance, false otherwise. bool sw_settings_has ( sw_settings_t * settings , const char * name ); class Settings final { ... // Returns true if the setting with the given name exists within the given // settings instance, false otherwise. bool has ( const std :: string & name ) const ; ... }; ! Returns .true. if the setting with the given name exists within the given ! settings instance, false otherwise. function settings_has ( settings , name ) result ( has ) class ( settings_t ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: name logical ( c_bool ) :: has end function A setting with the given name can be fetched. C C++ Fortran // Retrieves the setting with the given name. sw_settings_result_t sw_settings_get ( sw_settings_t * settings , const char * name ); class Settings final { ... // Retrieves a (string-valued) setting with the given name, throwing an // exception if it doesn't exist. std :: string get ( const std :: string & name ) const { ... }; ! Retrieves the setting with the given name, returning a result that can ! be checked for errors that occur. function settings_get_param ( settings , name ) result ( s_result ) class ( settings_t ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: name type ( settings_result_t ) :: s_result end function Fetching a setting fails if a setting with the given name doesn't exist. The C and Fortran interfaces define a result type that allows this situation to be handled. C Fortran typedef struct sw_setting_result_t { const char * value ; // fetched value (if error_code == 0) int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_settings_result_t ; type :: settings_result_t character ( len = 255 ) :: value ! fetched value (if error_code == 0) integer :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type settings_result_t On failure, the C++ interface throws a skywalker::Exception with a string description identical to the error_message description in the C and Fortran result types. For brevity, the Fortran interface also offers a function that halts your program if a setting is not found: Fortran ! Retrieves the setting with the given name, halting the program if an ! error occurs. function settings_get ( settings , name ) result ( str ) class ( settings_t ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: name character ( len = 255 ) :: str end function","title":"Applying Program Settings"},{"location":"api/#processing-an-ensemble-member","text":"The bulk of your Skywalker program is concerned with processing each member of an ensemble. To do this, you must loop over the ensemble, retrieving the input and output variables for each member read input parameters from the member's input variable use the input parameters to compute output. set the output parameters in the member's output variable","title":"Processing an Ensemble Member"},{"location":"api/#looping-over-ensemble-members","text":"Skywalker handles the process of looping over the ensemble for you. In C and Fortran, you can construct a loop that calls a function to get the input and output parameters for each member, terminating when there are no members left. C Fortran // Iterates over the inputs and outputs in an ensemble, making them available // one at a time for computation. This function returns true once for each // member of an ensemble and false once the ensemble's members have been // traversed. Use it as a predicate in a while loop in which inputs and outputs // are processed. bool sw_ensemble_next ( sw_ensemble_t * ensemble , sw_input_t ** input , sw_output_t ** output ); ! Iterates over the inputs and outputs in an ensemble, making them available ! one at a time for computation. This function returns true once for each ! member of an ensemble and false once the ensemble's members have been ! traversed. Use it as a predicate in a do while loop in which inputs and ! outputs are processed. function ensemble_next ( ensemble , input , output ) result ( next ) class ( ensemble_t ), intent ( in ) :: ensemble type ( input_t ), intent ( out ) :: input type ( output_t ), intent ( out ) :: output logical ( c_bool ) :: next end function In C++, you can write your own function that performs the processing, and pass that function to a method on your Ensemble object. This executes your function on the input and output data for each member. The function you define takes a const reference to an Input object and a non- const reference to an Output object, and returns nothing. C++ class Ensemble final { ... // Iterates over all ensemble members, applying the given function f to // each input/output pair. void process ( std :: function < void ( const Input & , Output & ) > f ); ... }; The examples and tests illustrate how this is done.","title":"Looping over ensemble members"},{"location":"api/#reading-input-parameters","text":"To read an input parameter from an ensemble member, you can retrieve its value using its name. It's easy to check whether the ensemble member has a given parameter: C C++ Fortran // Returns true if a (scalar) input parameter with the given name exists // within the given input instance, false otherwise. bool sw_input_has ( sw_input_t * input , const char * name ); class Input final { ... // Returns true if the input parameter with the given name exists within // the given input instance, false otherwise. bool has ( const std :: string & name ) const ; ... }; ! Returns .true. if the input parameter with the given name exists within the ! given input instance, false otherwise. function input_has ( input , name ) result ( has ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name logical ( c_bool ) :: has end function Similarly, it's easy to fetch the parameter: C C++ Fortran // Retrieves the (scalar) input parameter with the given name. sw_input_result_t sw_input_get ( sw_input_t * input , const char * name ); class Input final { ... // Retrieves a (real-valued) parameter with the given name, throwing an // exception if it doesn't exist. Real get ( const std :: string & name ) const ; ... }; ! Retrieves the input parameter with the given name. function input_get_param ( input , name ) result ( i_result ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name type ( input_result_t ) :: i_result end function Fetching a parameter fails if the parameter doesn't exist within the ensemble. The C and Fortran interfaces return a result type that allows you to check whether the operation succeeded. C Fortran typedef struct sw_input_result_t { sw_real_t value ; // fetched value (if error_code == 0) int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_input_result_t ; type :: input_result_t real ( c_real ) :: value ! fetched value (if error_code == 0) integer ( c_int ) :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type input_result_t In C++, a skywalker::Exception is thrown in the case of failure, with an error string identical to the error_message field of the corresponding C and Fortran result types. The Fortran interface also offers you a \"shortcut\" that directly fetches your input parameter, halting your program with STOP on failure. Fortran ! Retrieves the input parameter with the given name, halting the program ! on failure. function input_get ( input , name ) result ( val ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name real ( c_real ) :: val end function","title":"Reading input parameters"},{"location":"api/#reading-input-array-parameters","text":"Skywalker offers you the ability to work with arrays of real-valued input parameters identified by a single name. These array parameters work the same as their scalar counterparts. Their memory is managed by Skywalker, so there's no need for you to perform any memory allocation. As with scalar input parameters, you can check to see whether an input array parameter exists within an ensemble member. C C++ Fortran // Returns true if an input array parameter with the given name exists within // the given input instance, false otherwise. bool sw_input_has_array ( sw_input_t * input , const char * name ); class Input final { ... // Returns true if an input array parameter with the given name exists within // the given input instance, false otherwise. bool has_array ( const std :: string & name ) const ; ... }; ! Returns .true. if an input array parameter with the given name exists within ! the given input instance, false otherwise. function input_has_array ( input , name ) result ( has ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name logical ( c_bool ) :: has end function The process of retrieving input array parameters works the same way as it does for scalar input parameters. C C++ Fortran // Retrieves the (array-valued) input parameter with the given name. sw_input_array_result_t sw_input_get_array ( sw_input_t * input , const char * name ); class Input final { ... // Retrieves a (real-valued) array parameter with the given name, throwing an // exception if it doesn't exist. std :: vector < Real > get_array ( const std :: string & name ) const ; }; ! Retrieves the input array parameter with the given name. function input_get_array_param ( input , name ) result ( i_result ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name type ( input_array_result_t ) :: i_result end function The C and Fortran interface define result types for fetching input array parameters. C Fortran typedef struct sw_input_array_result_t { sw_real_t * values ; // fetched values (if error_code == 0) size_t size ; // number of values (if error_code == 0) int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_input_array_result_t ; type :: input_array_result_t real ( c_real ), dimension (:), pointer :: values ! fetched values (if error_code == 0) integer ( c_size_t ) :: size ! number of values (if error_code == 0) integer ( c_int ) :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type input_array_result_t As with scalar input parameters, the C++ interface throws a skywalker::Exception if it cannot retrieve a given input array parameter. And, as in the scalar case, the Fortran interface also defines a subroutine that tries to fetch an array parameter and halts with STOP on failure. Fortran ! Retrieves the input array parameter with the given name, halting on ! failure. subroutine input_get_array ( input , name , values ) class ( input_t ), intent ( in ) :: input character ( len =* ), intent ( in ) :: name real ( c_real ), allocatable , dimension (:), intent ( inout ) :: values end subroutine If you use this subroutine, you must deallocate the values array when you're finished with it.","title":"Reading input array parameters"},{"location":"api/#computing-output-parameters-from-input-parameters","text":"This is where you do your thing. Nobody knows your job better than you! Remember that all input and output parameters are floating point numbers, so if your work uses integer inputs or outputs, you must perform all necessary type casting.","title":"Computing output parameters from input parameters"},{"location":"api/#setting-output-parameters","text":"When you've computed an output value from one or more input values, you'll want to store that value by name in the ensemble member's output data. To do this, you can call a function to set the value of a named output parameter. C C++ Fortran // This function sets a quantity with the given name and value within the given // output instance. This operation cannot fail under normal circumstances. void sw_output_set ( sw_output_t * output , const char * name , sw_real_t value ); class Output final { ... // Sets a (real-valued) parameter with the given name. This operation // cannot fail under normal circumstances. void set ( const std :: string & name , Real value ) const ; ... }; ! Sets a quantity with the given name and value within the given output ! instance. This operation cannot fail under normal circumstances. subroutine output_set ( output , name , value ) class ( output_t ), intent ( in ) :: output character ( len =* ), intent ( in ) :: name real ( c_real ), intent ( in ) :: value end subroutine The operation of setting an output parameter can't fail under normal circumstances (sufficient memory, good hardware, etc). Skywalker handles all the bookkeeping details.","title":"Setting output parameters"},{"location":"api/#setting-output-array-parameters","text":"Output array parameters work the same way as input array parameters: they're just output values that share a common name. You can set an array-valued output parameter by calling the appropriate function or subroutine. C C++ Fortran // This function sets an array of quantities with the given name and values // within the given output instance. This operation cannot fail under normal // circumstances. void sw_output_set_array ( sw_output_t * output , const char * name , const sw_real_t * values , size_t size ); class Output final { ... // Sets (real-valued) parameters in an array with the given name. This // operation cannot fail under normal circumstances. void set ( const std :: string & name , const std :: vector < Real > & values ) const ; ... }; ! Sets an array of quantities with the given name and values to the given ! output instance. This operation cannot fail under normal circumstances. subroutine output_set_array ( output , name , values ) class ( output_t ), intent ( in ) :: output character ( len =* ), intent ( in ) :: name real ( c_real ), target , intent ( in ), dimension (:) :: values end subroutine As with scalar output parameters, the operation of setting an output array parameter cannot fail under normal circumstances.","title":"Setting output array parameters"},{"location":"api/#writing-ensemble-output","text":"At the end of your program, you can call a function to write all your ensemble data to a Python module that be postprocessed. C C++ Fortran // Writes input and output data within the ensemble to a Python module stored // in the file with the given name. sw_write_result_t sw_ensemble_write ( sw_ensemble_t * ensemble , const char * module_filename ); class Ensemble final { ... // Writes input and output data within the ensemble to a Python module stored // in the file with the given name. void write ( const std :: string & module_filename ) const ; ... }; ! Writes input and output data within the ensemble to a Python module stored ! in the file with the given name. function ensemble_write_module ( ensemble , module_filename ) result ( w_result ) class ( ensemble_t ), intent ( in ) :: ensemble character ( len =* ), intent ( in ) :: module_filename type ( write_result_t ) :: w_result end subroutine Because it attempts to write a file, this operation can fail. The C and Fortran interfaces define a result type that can capture the information needed to handle this failure. C Fortran typedef struct sw_write_result_t { int error_code ; // error code indicating success or failure const char * error_message ; // text description of error } sw_write_result_t ; type :: write_result_t integer ( c_int ) :: error_code ! error code indicating success or failure character ( len = 255 ) :: error_message ! text description of error end type write_result_t As usual, the C++ interface throws a skywalker::Exception containing a string identical to the error_message field found in the corresponding C and Fortran result types. And, as usual, there is a Fortran subroutine that attempts to write the ensemble data to the given file and halts on failure. Fortran ! Writes input and output data within the ensemble to a Python module stored ! in the file with the given name, halting on failure. subroutine ensemble_write ( ensemble , module_filename ) class ( ensemble_t ), intent ( in ) :: ensemble character ( len =* ), intent ( in ) :: module_filename end subroutine","title":"Writing Ensemble Output"},{"location":"api/#cleanup","text":"After you've written the Python module, you should free the resources your ensemble uses by destroying it. In C and Fortran, you can do this with a simple function call. C Fortran // Destroys an ensemble, freeing its allocated resources. Use this at the end // of your driver program, or when a fatal error has been encountered. void sw_ensemble_free ( sw_ensemble_t * ensemble ); ! Destroys an ensemble, freeing all allocated resources. subroutine ensemble_free ( ensemble ) class ( ensemble_t ), intent ( in ) :: ensemble end subroutine In C++, you can simply delete the Ensemble pointer you obtained by calling skywalker::load_ensemble , or you can use a smart pointer to store the ensemble.","title":"Cleanup"},{"location":"api/#miscellaneous","text":"In addition to the types and interfaces we've described, there are a few extra functions you might find handy in your Skywalker program.","title":"Miscellaneous"},{"location":"api/#printing-a-banner","text":"You can write a banner to the standard error strstream ( stderr in C and C++) with a call to the appropriate function. C C++ Fortran // Prints a banner containing Skywalker's version info to stderr. void sw_print_banner ( void ); namespace skywalker { ... // Prints a banner containing Skywalker's version info to stderr. void print_banner () { ... } // namespace skywalker ! Prints a banner containing Skywalker's version info to stderr. subroutine print_banner () end subroutine This banner prints out the version of Skywalker used by your program. This can be helpful if you think you've encountered a bug in Skywalker, or if you're trying to use a newer feature of the library.","title":"Printing a banner"},{"location":"api/#getting-the-ensembles-size","text":"Sometimes it helps to know how many members an ensemble contains. C C++ Fortran // Returns the size of the given ensemble. size_t sw_ensemble_size ( sw_ensemble_t * ensemble ); class Ensemble { ... // Returns the size of the ensemble (number of members). size_t size () const ; ... }; The ensemble's size is stored in the size field of the ensemble_t derived type.","title":"Getting the ensemble's size"},{"location":"example/","text":"Example: Van der Waals Gas The example in this section focuses on the Van der Waals gas law , a generalization of the ideal gas law that accurately describes many gases over a great range of temperatures, pressures, and volumes. The example has three parts. In this example, we use the Standard International (SI, also called mks ) system of units. When we define a quantity, we denote its units in square brackets. For example, the mass of an object could be written as \\(m\\) [kg]. Quantities without units are followed by [-]. The code for the example is available in the examples folder of the Skywalker source tree. We'll use Python to make a few plots along the way. We use Python 3 and the matplotlib library, which comes with many scientific Python packages like IPython . If you're not using one of those packages, you can usually install matplotlib with a command like the following: pip3 install matplotlib Ideal gas Recall that the ideal gas law relates the pressure, temperature, and volume of a gas through the equation of state \\[ pV = \\nu R T \\] where \\(p\\) is the gas pressure [Pa] \\(V\\) is the volume occupied by the gas [m \\(^3\\) ] \\(\\nu\\) is the number of moles of gas contained in the volume \\(V\\) [-] \\(R\\) is the universal gas constant [J \\(\\cdot\\) K \\(^{-1} \\cdot\\) mol \\(^{-1}\\) ] \\(T\\) is the temperature of the gas [K] Strictly speaking, the ideal gas law holds for gases whose molecules don't interact with one another. While this is not true for any known substance, it's a good approximation for gases whose molecules interact only weakly. Van der Waals gas The equation of state for the van der Waals gas law is a refinement of the ideal gas law that attempts to model weak interactions between particles using a pair of parameters \\(a\\) and \\(b\\) . The equation is \\[ (p + a/V^2)(V - b) = \\nu RT \\] where \\(a\\) represents the effects of cohesive forces within a molecule, and \\(b\\) represents effects of molecules having a finite size . Clearly, when \\(a=b=0\\) , this equation reverts to the ideal gas law. The Van der Waals approximation is a significant improvement on the ideal gas law, and can be used to study various phenomena. Our discussion follows that in Chapter IV of Thermodynamics , by Enrico Fermi, Dover Publications, NY (1936). Part 1: Plotting Isotherms An isotherm is a thermodynamic process in which the temperature remains the same throughout. Isothermal processes are important in any setting in which smaller physical systems interact with a heat reservoir at a given temperature. They are conveniently expressed using PV diagrams , which are just XY plots with the volume \\(V\\) on the \\(x\\) axis and the pressure \\(p\\) on the \\(y\\) axis. Ideal gas We can construct an isotherm curve for an ideal gas by writing the pressure \\(p\\) as a function of \\(V\\) and \\(T\\) for a single mole of gas ( \\(\\nu = 1\\) ): \\[ p(V, T) = \\frac{RT}{V} \\] Let's write a simple Skywalker program that takes \\(V\\) and \\(T\\) as input and computes \\(p\\) as output. Our program will read the following input file, named ideal_gas_isotherms , which constructs an ensemble of \\((V, T)\\) pairs, with \\(V \\in [5^{-5}, 1^{-3}]\\) m \\({^3}\\) and \\(T\\) assuming the values 273 K, 373 K, 473 K, 573 K, and 673 K. ideal_gas_isotherms.yaml input: lattice: V: [5.0e-5, 1.0e-3, 1.0e-6] # [m^3] T: [273, 373, 473, 573, 673] # [K] Here's our program: C C++ Fortran 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // isotherms.c #include <skywalker.h> // This function retrieves the value with the given name from the given // input, exiting on failure. sw_real_t get_value ( sw_input_t * input , const char * name ) { sw_input_result_t in_result = sw_input_get ( input , name ); if ( in_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"isotherms_c: %s\" , in_result . error_message ); exit ( -1 ); } return in_result . value ; } // Here's the main function. int main ( int argc , char ** argv ) { const char * input_file = \"ideal_gas_isotherms.yaml\" ; // Load the ensemble. Any error encountered is fatal. printf ( \"isotherms_c: Loading ensemble from %s... \\n \" , input_file ); sw_ensemble_result_t load_result = sw_load_ensemble ( input_file , NULL ); if ( load_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"isotherms_c: %s\" , load_result . error_message ); exit ( -1 ); } sw_ensemble_t * ensemble = load_result . ensemble ; printf ( \"isotherms_c: found %zd ensemble members. \\n \" , sw_ensemble_size ( ensemble )); // Iterate over all members of the ensemble. sw_input_t * input ; sw_output_t * output ; while ( sw_ensemble_next ( ensemble , & input , & output )) { // Fetch (V, T) from the member's input. sw_real_t V = get_value ( input , \"V\" ); // gas (molar) volume [m3] sw_real_t T = get_value ( input , \"T\" ); // gas temperature [K] // Compute p(V, T). static const sw_real_t R = 8.31446261815324 ; sw_real_t p = R * T / V ; // Stash the computed pressure in the member's output. sw_output_set ( output , \"p\" , p ); } // Write out a Python module. const char * output_file = \"ideal_gas_isotherms_c.py\" ; printf ( \"isotherms_c: Writing data to %s... \\n \" , output_file ); sw_write_result_t w_result = sw_ensemble_write ( ensemble , output_file ); if ( w_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"isotherms_c: %s \\n \" , w_result . error_message ); exit ( -1 ); } // Clean up. sw_ensemble_free ( ensemble ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // isotherms.cpp #include <skywalker.hpp> int main ( int argc , char ** argv ) { std :: string input_file = \"ideal_gas_isotherms.yaml\" ; // Load the ensemble. Any error encountered is fatal. std :: cout << \"isotherms_cpp: Loading ensemble from \" << input_file << \"... \\n \" ; skywalker :: Ensemble * ensemble = nullptr ; try { ensemble = skywalker :: load_ensemble ( input_file ); } catch ( skywalker :: Exception & e ) { std :: cerr << \"isotherms_cpp: \" << e . what () << std :: endl ; exit ( -1 ); } std :: cout << \"isotherms_cpp: found \" << ensemble -> size () << \" ensemble members. \\n \" ; // Iterate over all members of the ensemble. try { ensemble -> process ([]( const skywalker :: Input & input , skywalker :: Output & output ) { // Fetch inputs. skywalker :: Real V = input . get ( \"V\" ); // gas (molar) volume [m3] skywalker :: Real T = input . get ( \"T\" ); // gas temperature [K] // Compute p(V, T). static const skywalker :: Real R = 8.31446261815324 ; skywalker :: Real p = R * T / V ; // Stash the computed pressure in the member's output. output . set ( \"p\" , p ); }); } catch ( skywalker :: Exception & e ) { std :: cerr << \"isotherms_cpp: \" << e . what () << \" \\n \" ; exit ( -1 ); } // Write out a Python module. std :: string output_file = \"ideal_gas_isotherms_cpp.py\" ; std :: cout << \"isotherms_cpp: Writing data to \" << output_file << \"... \\n \" ; try { ensemble -> write ( output_file ); } catch ( skywalker :: Exception & e ) { std :: cerr << \"isotherms_cpp: \" << e . what () << \" \\n \" ; exit ( -1 ); } // Clean up. delete ensemble ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ! isotherms.F90 program isotherms use iso_c_binding , only : c_float , c_double use skywalker implicit none ! Universal gas constant real ( swp ), parameter :: R = 8.31446261815324_swp character ( len = 255 ) :: input_file , output_file type ( ensemble_result_t ) :: load_result type ( ensemble_t ) :: ensemble type ( input_t ) :: input type ( output_t ) :: output real ( swp ) :: V , T , p , a , b input_file = \"ideal_gas_isotherms.yaml\" ! Load the ensemble. Any error encountered is fatal. print * , \"isotherms_f90: Loading ensemble from \" , trim ( input_file ), \"...\" load_result = load_ensemble ( trim ( input_file )) if ( load_result % error_code /= SW_SUCCESS ) then print * , \"isotherms_f90: \" , trim ( load_result % error_message ) stop end if ensemble = load_result % ensemble print * , \"isotherms_f90: found \" , ensemble % size , \" ensemble members.\" ! Iterate over all members of the ensemble. do while ( ensemble % next ( input , output )) ! Fetch inputs. V = input % get ( \"V\" ) ! gas (molar) volume [m3] T = input % get ( \"T\" ) ! gas temperature [K] ! Compute p(V, T). p = R * T / V ! Stash the computed pressure in the member's output. call output % set ( \"p\" , p ); end do ! Write out a Python module. output_file = \"ideal_gas_isotherms_f90.py\" print * , \"isotherms_f90: Writing data to \" , output_file , \"...\" call ensemble % write ( output_file ) ! Clean up. call ensemble % free (); end program Click through the different tabs for the C, C++, and Fortran versions of the program. You can see that they're very similar. Here's what's going on: An ensemble is loaded with a load_ensemble function. If the attempt to load the ensemble fails, the program halts. The members of the ensemble are processed one by one. In the C and Fortran programs, this happens in a while / do while loop, in which a call to sw_ensemble_next or ensemble%next associates the input and output variables with a specific ensemble member. In C++, this loop is hidden inside a call to ensemble->process , which accepts a lambda function whose arguments are the properly associated input and output variables for each member. Inside this loop: the gas volume \\(V\\) and temperature \\(T\\) are extracted from the input variable for the current ensemble member the gas pressure \\(p\\) is computed from \\(V\\) and \\(T\\) the computed pressure \\(p\\) is stored in the output variable for the current ensemble member After every ensemble member has been processed in Step 2, a Python module containing all input and output data for the ensemble is written. The ensemble is deleted with an appropriate function call or command. For a more detailed explanation of any of these steps, see the API section. If you like, copy and paste any version of the program into a text editor, save it, and build it, linking it against libskywalker.a or libskywalker_f90.a as needed. Then run it in a directory containing ideal_gas_isotherms.yaml , and check to see that an appropriate .py file appears. Here's a plot of the resulting isotherms: If you want to generate this plot for yourself, run the plot_isotherms.py script in the examples/ folder of the repo on the appropriate .py file, leaving out the .py suffix. E.g. python3 plot_isotherms.py ideal_gas_isotherms_c Van der Waals gases Now that we've successfully used Skywalker to plot the isotherms of an ideal gas at several temperatures, we can generalize our program(s) to handle Van der Waals gases. The expression for the gas pressure is \\[ p = \\frac{RT}{V - b} - \\frac{a}{V^2} \\] First, we must add the two parameters \\(a\\) and \\(b\\) as input. Here's a YAML input file that sets these parameters for diatomic nitrogen gas: n2_gas_isotherms.yaml input: fixed: a: 0.137 # [Pa m6/mol2] b: 3.87e-5 # [m3/mol] lattice: V: [5.0e-5, 1.0e-3, 1.0e-6] # [m^3] T: [273, 373, 473, 573, 673] # [K] And here's one for carbon dioxide: co2_gas_isotherms.yaml input: fixed: a: 0.3658 # [J m3/mol2] b: 4.29e-5 # [m3/mol] lattice: V: [5.0e-5, 1.0e-3, 1.0e-6] # [m3] T: [273, 373, 473, 573, 673] # [K] Now we must modify our programs to include these input parameters in the calculation of the gas pressure. Here are code snippets that implement these changes: C C++ Fortran Replace lines 38-40 with 38 39 40 41 42 43 44 45 46 47 48 49 // Fetch Van der Waals parameters if they're present. sw_real_t a = 0.0 , b = 0.0 ; if ( sw_input_has ( input , \"a\" )) { a = get_value ( input , \"a\" ); } if ( sw_input_has ( input , \"b\" )) { b = get_value ( input , \"b\" ); } // Compute p(V, T). static const sw_real_t R = 8.31446261815324 ; sw_real_t p = R * T / ( V - b ) - a / ( V * V ); Replace lines 26-28 with 26 27 28 29 30 31 32 33 34 35 36 37 // Fetch Van der Waals parameters if they're present. skywalker :: Real a = 0.0 , b = 0.0 ; if ( input . has ( \"a\" )) { a = input . get ( \"a\" ); } if ( input . has ( \"b\" )) { b = input . get ( \"b\" ); } // Compute p(V, T). static const skywalker :: Real R = 8.31446261815324 ; skywalker :: Real p = R * T / ( V - b ) - a / ( V * V ); Declare real(swp) variables a and b , and replace lines 39-40 with 39 40 41 42 43 44 45 46 ! Fetch Van der Waals parameters if they're present. a = 0.0_swp b = 0.0_swp if ( input % has ( \"a\" )) a = input % get ( \"a\" ) if ( input % has ( \"b\" )) b = input % get ( \"b\" ) ! Compute p(V, T). p = R * T / ( V - b ) - a / ( V ** 2 ) With these changes, the program can now build the ensembles indicated in the n2_gas_isotherms.yaml and co2_gas_isotherms.yaml files. Here are all of the resulting plots (including our ideal gas for comparison): Ideal gas N2 gas CO2 gas Exercises Experiment with different values of \\(a\\) and \\(b\\) . Are there values that trigger interesting or surprising behavior? Try to interpret these values physically. Part 2: Determining the Saturation Vapor Pressure in Carbon Dioxide You may be curious about what's happening with the blue curve representing the isotherm for \\(T = 273\\) K for carbon dioxide. If you follow the curve starting from the right, it represents a compression process for the gas at a constant temperature. Somewhere around \\(V = 2 \\times 10^{-4}\\) m \\(^3\\) , something funny happens: the gas pressure decreases under compression. This simply doesn't happen in reality. What's going on? What's going on is a phase change: carbon dioxide condenses to liquid form under these conditions. The gas is no longer in a homogeneous state, and the Van der Waals equation of state isn't satisfied for the gas/liquid mixture. Rather, the pressure (called the saturation vapor pressure ) remains constant alongside the temperature over the course of the phase change. One way to understand this is that under a phase change, the system alters its binding energy but not its kinetic energy. The pressure in a Van der Waals gas depends only on its kinetic energy (because it assumes that the particles interact only weakly), so it remains constant. In other words, the saturation vapor pressure is a horizontal line \\(p(V) = p_s\\) over the course of the phase change. It looks like this: Suppose we wanted to modify our program to make use of these ideas. Our objective is to find the value of the saturation pressure, or the height of the horizontal line in the vicinity of the phase change. One might think that we must use the Clausius-Clapeyron equation , which involves the latent heat of evaporation and the specific volumes of the gas and liquid phases. However, the shape of the isotherm in question actually gives us enough geometric information to use an iterative approach that does a decent job of estimating the saturation vapor pressure using Maxwell's equal area rule . Approximating the saturation vapor pressure numerically We don't have a curve \\(p(V)\\) to work with in our calculation of \\(V_s\\) --we only have a discrete set of points with volumes \\(\\{V_i\\}\\) and pressures \\(\\{p_i\\}\\) . Let \\(i_1\\) be the index of the first point along the (horizontal) phase change curve, and let \\(i_2\\) be the index of the last point along this curve. These two points have the same pressure, which is the saturation vapor pressure. How do we determine them? Suppose we start the points at two distinctive locations and move them around till they have equal pressure. For example, we can set \\(i_1\\) to the point at the trough of the Van der Waals isotherm, and \\(i_2\\) to the local peak to the right of this trough. Then we know that our initial value of \\(i_1\\) is too large, and that our initial value of \\(i_2\\) is too small. We can now devise an iterative scheme that moves \\(i_1\\) and \\(i_2\\) apart until the difference in their pressures hits a minimum. pdiff := abs(p(i2) - p(i1)) Do forever # Trying moving i1 to the left, reversing if we hit a higher # pressure difference. prev_i1 := i1 i1 := i1 - 1 p21 := abs(p(i2) - p(i1)) if p21 < pdiff pdiff := p21 else i1 := i1 + 1 # Trying moving i2 to the right. prev_i2 := i2 i2 := i2 + 1 p21 := abs(p(i2) - p(i1)) if p21 < pdiff pdiff := p21 else i2 := i2 - 1 # If we didn't move either point, we're finished. if i1 = prev_i1 and i2 = prev_i2 break Once we've found a plausible saturation vapor pressure, we can increase or decrease it until the areas bounded by the original curve and the flat saturation pressure sum to zero. These areas are described by the integral of the pressure over the range of volumes in question, so what we're looking for is \\[ \\int_{V_1}^{V_2} (p - p_s) \\texttt{d}V = 0, \\] or \\[ \\int_{V_1}^{V_s} (p - p_s) \\texttt{d}V + \\int_{V_s}^{V_2} (p - p_s) \\texttt{d}V = 0, \\] where $p_s = p(V_s) $ is the saturation vapor pressure and \\(V_1\\) and \\(V_2\\) are, respectively, the minimum and maximum volumes at which \\((p(V) = p_s\\) in the original Van der Waals pressure curves. These integrals can be approximated using a simple quadrature rule such as the midpoint rule. Exercises Try to implement this iterative scheme to compute the saturation vapor pressure for the above isotherm. (Hint: use an input that specifies a single temperature.) Extra credit: can you add a setting to your program that specifies whether or not to compute the saturation vapor pressure? You can read about settings in the Input Format and API sections. Can you find the critical point for carbon dioxide by exploring various Van der Waals isotherms? How do you know when you've found it?","title":"Example: Van der Waals Gas"},{"location":"example/#example-van-der-waals-gas","text":"The example in this section focuses on the Van der Waals gas law , a generalization of the ideal gas law that accurately describes many gases over a great range of temperatures, pressures, and volumes. The example has three parts. In this example, we use the Standard International (SI, also called mks ) system of units. When we define a quantity, we denote its units in square brackets. For example, the mass of an object could be written as \\(m\\) [kg]. Quantities without units are followed by [-]. The code for the example is available in the examples folder of the Skywalker source tree. We'll use Python to make a few plots along the way. We use Python 3 and the matplotlib library, which comes with many scientific Python packages like IPython . If you're not using one of those packages, you can usually install matplotlib with a command like the following: pip3 install matplotlib","title":"Example: Van der Waals Gas"},{"location":"example/#ideal-gas","text":"Recall that the ideal gas law relates the pressure, temperature, and volume of a gas through the equation of state \\[ pV = \\nu R T \\] where \\(p\\) is the gas pressure [Pa] \\(V\\) is the volume occupied by the gas [m \\(^3\\) ] \\(\\nu\\) is the number of moles of gas contained in the volume \\(V\\) [-] \\(R\\) is the universal gas constant [J \\(\\cdot\\) K \\(^{-1} \\cdot\\) mol \\(^{-1}\\) ] \\(T\\) is the temperature of the gas [K] Strictly speaking, the ideal gas law holds for gases whose molecules don't interact with one another. While this is not true for any known substance, it's a good approximation for gases whose molecules interact only weakly.","title":"Ideal gas"},{"location":"example/#van-der-waals-gas","text":"The equation of state for the van der Waals gas law is a refinement of the ideal gas law that attempts to model weak interactions between particles using a pair of parameters \\(a\\) and \\(b\\) . The equation is \\[ (p + a/V^2)(V - b) = \\nu RT \\] where \\(a\\) represents the effects of cohesive forces within a molecule, and \\(b\\) represents effects of molecules having a finite size . Clearly, when \\(a=b=0\\) , this equation reverts to the ideal gas law. The Van der Waals approximation is a significant improvement on the ideal gas law, and can be used to study various phenomena. Our discussion follows that in Chapter IV of Thermodynamics , by Enrico Fermi, Dover Publications, NY (1936).","title":"Van der Waals gas"},{"location":"example/#part-1-plotting-isotherms","text":"An isotherm is a thermodynamic process in which the temperature remains the same throughout. Isothermal processes are important in any setting in which smaller physical systems interact with a heat reservoir at a given temperature. They are conveniently expressed using PV diagrams , which are just XY plots with the volume \\(V\\) on the \\(x\\) axis and the pressure \\(p\\) on the \\(y\\) axis.","title":"Part 1: Plotting Isotherms"},{"location":"example/#ideal-gas_1","text":"We can construct an isotherm curve for an ideal gas by writing the pressure \\(p\\) as a function of \\(V\\) and \\(T\\) for a single mole of gas ( \\(\\nu = 1\\) ): \\[ p(V, T) = \\frac{RT}{V} \\] Let's write a simple Skywalker program that takes \\(V\\) and \\(T\\) as input and computes \\(p\\) as output. Our program will read the following input file, named ideal_gas_isotherms , which constructs an ensemble of \\((V, T)\\) pairs, with \\(V \\in [5^{-5}, 1^{-3}]\\) m \\({^3}\\) and \\(T\\) assuming the values 273 K, 373 K, 473 K, 573 K, and 673 K. ideal_gas_isotherms.yaml input: lattice: V: [5.0e-5, 1.0e-3, 1.0e-6] # [m^3] T: [273, 373, 473, 573, 673] # [K] Here's our program: C C++ Fortran 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // isotherms.c #include <skywalker.h> // This function retrieves the value with the given name from the given // input, exiting on failure. sw_real_t get_value ( sw_input_t * input , const char * name ) { sw_input_result_t in_result = sw_input_get ( input , name ); if ( in_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"isotherms_c: %s\" , in_result . error_message ); exit ( -1 ); } return in_result . value ; } // Here's the main function. int main ( int argc , char ** argv ) { const char * input_file = \"ideal_gas_isotherms.yaml\" ; // Load the ensemble. Any error encountered is fatal. printf ( \"isotherms_c: Loading ensemble from %s... \\n \" , input_file ); sw_ensemble_result_t load_result = sw_load_ensemble ( input_file , NULL ); if ( load_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"isotherms_c: %s\" , load_result . error_message ); exit ( -1 ); } sw_ensemble_t * ensemble = load_result . ensemble ; printf ( \"isotherms_c: found %zd ensemble members. \\n \" , sw_ensemble_size ( ensemble )); // Iterate over all members of the ensemble. sw_input_t * input ; sw_output_t * output ; while ( sw_ensemble_next ( ensemble , & input , & output )) { // Fetch (V, T) from the member's input. sw_real_t V = get_value ( input , \"V\" ); // gas (molar) volume [m3] sw_real_t T = get_value ( input , \"T\" ); // gas temperature [K] // Compute p(V, T). static const sw_real_t R = 8.31446261815324 ; sw_real_t p = R * T / V ; // Stash the computed pressure in the member's output. sw_output_set ( output , \"p\" , p ); } // Write out a Python module. const char * output_file = \"ideal_gas_isotherms_c.py\" ; printf ( \"isotherms_c: Writing data to %s... \\n \" , output_file ); sw_write_result_t w_result = sw_ensemble_write ( ensemble , output_file ); if ( w_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"isotherms_c: %s \\n \" , w_result . error_message ); exit ( -1 ); } // Clean up. sw_ensemble_free ( ensemble ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // isotherms.cpp #include <skywalker.hpp> int main ( int argc , char ** argv ) { std :: string input_file = \"ideal_gas_isotherms.yaml\" ; // Load the ensemble. Any error encountered is fatal. std :: cout << \"isotherms_cpp: Loading ensemble from \" << input_file << \"... \\n \" ; skywalker :: Ensemble * ensemble = nullptr ; try { ensemble = skywalker :: load_ensemble ( input_file ); } catch ( skywalker :: Exception & e ) { std :: cerr << \"isotherms_cpp: \" << e . what () << std :: endl ; exit ( -1 ); } std :: cout << \"isotherms_cpp: found \" << ensemble -> size () << \" ensemble members. \\n \" ; // Iterate over all members of the ensemble. try { ensemble -> process ([]( const skywalker :: Input & input , skywalker :: Output & output ) { // Fetch inputs. skywalker :: Real V = input . get ( \"V\" ); // gas (molar) volume [m3] skywalker :: Real T = input . get ( \"T\" ); // gas temperature [K] // Compute p(V, T). static const skywalker :: Real R = 8.31446261815324 ; skywalker :: Real p = R * T / V ; // Stash the computed pressure in the member's output. output . set ( \"p\" , p ); }); } catch ( skywalker :: Exception & e ) { std :: cerr << \"isotherms_cpp: \" << e . what () << \" \\n \" ; exit ( -1 ); } // Write out a Python module. std :: string output_file = \"ideal_gas_isotherms_cpp.py\" ; std :: cout << \"isotherms_cpp: Writing data to \" << output_file << \"... \\n \" ; try { ensemble -> write ( output_file ); } catch ( skywalker :: Exception & e ) { std :: cerr << \"isotherms_cpp: \" << e . what () << \" \\n \" ; exit ( -1 ); } // Clean up. delete ensemble ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ! isotherms.F90 program isotherms use iso_c_binding , only : c_float , c_double use skywalker implicit none ! Universal gas constant real ( swp ), parameter :: R = 8.31446261815324_swp character ( len = 255 ) :: input_file , output_file type ( ensemble_result_t ) :: load_result type ( ensemble_t ) :: ensemble type ( input_t ) :: input type ( output_t ) :: output real ( swp ) :: V , T , p , a , b input_file = \"ideal_gas_isotherms.yaml\" ! Load the ensemble. Any error encountered is fatal. print * , \"isotherms_f90: Loading ensemble from \" , trim ( input_file ), \"...\" load_result = load_ensemble ( trim ( input_file )) if ( load_result % error_code /= SW_SUCCESS ) then print * , \"isotherms_f90: \" , trim ( load_result % error_message ) stop end if ensemble = load_result % ensemble print * , \"isotherms_f90: found \" , ensemble % size , \" ensemble members.\" ! Iterate over all members of the ensemble. do while ( ensemble % next ( input , output )) ! Fetch inputs. V = input % get ( \"V\" ) ! gas (molar) volume [m3] T = input % get ( \"T\" ) ! gas temperature [K] ! Compute p(V, T). p = R * T / V ! Stash the computed pressure in the member's output. call output % set ( \"p\" , p ); end do ! Write out a Python module. output_file = \"ideal_gas_isotherms_f90.py\" print * , \"isotherms_f90: Writing data to \" , output_file , \"...\" call ensemble % write ( output_file ) ! Clean up. call ensemble % free (); end program Click through the different tabs for the C, C++, and Fortran versions of the program. You can see that they're very similar. Here's what's going on: An ensemble is loaded with a load_ensemble function. If the attempt to load the ensemble fails, the program halts. The members of the ensemble are processed one by one. In the C and Fortran programs, this happens in a while / do while loop, in which a call to sw_ensemble_next or ensemble%next associates the input and output variables with a specific ensemble member. In C++, this loop is hidden inside a call to ensemble->process , which accepts a lambda function whose arguments are the properly associated input and output variables for each member. Inside this loop: the gas volume \\(V\\) and temperature \\(T\\) are extracted from the input variable for the current ensemble member the gas pressure \\(p\\) is computed from \\(V\\) and \\(T\\) the computed pressure \\(p\\) is stored in the output variable for the current ensemble member After every ensemble member has been processed in Step 2, a Python module containing all input and output data for the ensemble is written. The ensemble is deleted with an appropriate function call or command. For a more detailed explanation of any of these steps, see the API section. If you like, copy and paste any version of the program into a text editor, save it, and build it, linking it against libskywalker.a or libskywalker_f90.a as needed. Then run it in a directory containing ideal_gas_isotherms.yaml , and check to see that an appropriate .py file appears. Here's a plot of the resulting isotherms: If you want to generate this plot for yourself, run the plot_isotherms.py script in the examples/ folder of the repo on the appropriate .py file, leaving out the .py suffix. E.g. python3 plot_isotherms.py ideal_gas_isotherms_c","title":"Ideal gas"},{"location":"example/#van-der-waals-gases","text":"Now that we've successfully used Skywalker to plot the isotherms of an ideal gas at several temperatures, we can generalize our program(s) to handle Van der Waals gases. The expression for the gas pressure is \\[ p = \\frac{RT}{V - b} - \\frac{a}{V^2} \\] First, we must add the two parameters \\(a\\) and \\(b\\) as input. Here's a YAML input file that sets these parameters for diatomic nitrogen gas: n2_gas_isotherms.yaml input: fixed: a: 0.137 # [Pa m6/mol2] b: 3.87e-5 # [m3/mol] lattice: V: [5.0e-5, 1.0e-3, 1.0e-6] # [m^3] T: [273, 373, 473, 573, 673] # [K] And here's one for carbon dioxide: co2_gas_isotherms.yaml input: fixed: a: 0.3658 # [J m3/mol2] b: 4.29e-5 # [m3/mol] lattice: V: [5.0e-5, 1.0e-3, 1.0e-6] # [m3] T: [273, 373, 473, 573, 673] # [K] Now we must modify our programs to include these input parameters in the calculation of the gas pressure. Here are code snippets that implement these changes: C C++ Fortran Replace lines 38-40 with 38 39 40 41 42 43 44 45 46 47 48 49 // Fetch Van der Waals parameters if they're present. sw_real_t a = 0.0 , b = 0.0 ; if ( sw_input_has ( input , \"a\" )) { a = get_value ( input , \"a\" ); } if ( sw_input_has ( input , \"b\" )) { b = get_value ( input , \"b\" ); } // Compute p(V, T). static const sw_real_t R = 8.31446261815324 ; sw_real_t p = R * T / ( V - b ) - a / ( V * V ); Replace lines 26-28 with 26 27 28 29 30 31 32 33 34 35 36 37 // Fetch Van der Waals parameters if they're present. skywalker :: Real a = 0.0 , b = 0.0 ; if ( input . has ( \"a\" )) { a = input . get ( \"a\" ); } if ( input . has ( \"b\" )) { b = input . get ( \"b\" ); } // Compute p(V, T). static const skywalker :: Real R = 8.31446261815324 ; skywalker :: Real p = R * T / ( V - b ) - a / ( V * V ); Declare real(swp) variables a and b , and replace lines 39-40 with 39 40 41 42 43 44 45 46 ! Fetch Van der Waals parameters if they're present. a = 0.0_swp b = 0.0_swp if ( input % has ( \"a\" )) a = input % get ( \"a\" ) if ( input % has ( \"b\" )) b = input % get ( \"b\" ) ! Compute p(V, T). p = R * T / ( V - b ) - a / ( V ** 2 ) With these changes, the program can now build the ensembles indicated in the n2_gas_isotherms.yaml and co2_gas_isotherms.yaml files. Here are all of the resulting plots (including our ideal gas for comparison): Ideal gas N2 gas CO2 gas","title":"Van der Waals gases"},{"location":"example/#exercises","text":"Experiment with different values of \\(a\\) and \\(b\\) . Are there values that trigger interesting or surprising behavior? Try to interpret these values physically.","title":"Exercises"},{"location":"example/#part-2-determining-the-saturation-vapor-pressure-in-carbon-dioxide","text":"You may be curious about what's happening with the blue curve representing the isotherm for \\(T = 273\\) K for carbon dioxide. If you follow the curve starting from the right, it represents a compression process for the gas at a constant temperature. Somewhere around \\(V = 2 \\times 10^{-4}\\) m \\(^3\\) , something funny happens: the gas pressure decreases under compression. This simply doesn't happen in reality. What's going on? What's going on is a phase change: carbon dioxide condenses to liquid form under these conditions. The gas is no longer in a homogeneous state, and the Van der Waals equation of state isn't satisfied for the gas/liquid mixture. Rather, the pressure (called the saturation vapor pressure ) remains constant alongside the temperature over the course of the phase change. One way to understand this is that under a phase change, the system alters its binding energy but not its kinetic energy. The pressure in a Van der Waals gas depends only on its kinetic energy (because it assumes that the particles interact only weakly), so it remains constant. In other words, the saturation vapor pressure is a horizontal line \\(p(V) = p_s\\) over the course of the phase change. It looks like this: Suppose we wanted to modify our program to make use of these ideas. Our objective is to find the value of the saturation pressure, or the height of the horizontal line in the vicinity of the phase change. One might think that we must use the Clausius-Clapeyron equation , which involves the latent heat of evaporation and the specific volumes of the gas and liquid phases. However, the shape of the isotherm in question actually gives us enough geometric information to use an iterative approach that does a decent job of estimating the saturation vapor pressure using Maxwell's equal area rule .","title":"Part 2: Determining the Saturation Vapor Pressure in Carbon Dioxide"},{"location":"example/#approximating-the-saturation-vapor-pressure-numerically","text":"We don't have a curve \\(p(V)\\) to work with in our calculation of \\(V_s\\) --we only have a discrete set of points with volumes \\(\\{V_i\\}\\) and pressures \\(\\{p_i\\}\\) . Let \\(i_1\\) be the index of the first point along the (horizontal) phase change curve, and let \\(i_2\\) be the index of the last point along this curve. These two points have the same pressure, which is the saturation vapor pressure. How do we determine them? Suppose we start the points at two distinctive locations and move them around till they have equal pressure. For example, we can set \\(i_1\\) to the point at the trough of the Van der Waals isotherm, and \\(i_2\\) to the local peak to the right of this trough. Then we know that our initial value of \\(i_1\\) is too large, and that our initial value of \\(i_2\\) is too small. We can now devise an iterative scheme that moves \\(i_1\\) and \\(i_2\\) apart until the difference in their pressures hits a minimum. pdiff := abs(p(i2) - p(i1)) Do forever # Trying moving i1 to the left, reversing if we hit a higher # pressure difference. prev_i1 := i1 i1 := i1 - 1 p21 := abs(p(i2) - p(i1)) if p21 < pdiff pdiff := p21 else i1 := i1 + 1 # Trying moving i2 to the right. prev_i2 := i2 i2 := i2 + 1 p21 := abs(p(i2) - p(i1)) if p21 < pdiff pdiff := p21 else i2 := i2 - 1 # If we didn't move either point, we're finished. if i1 = prev_i1 and i2 = prev_i2 break Once we've found a plausible saturation vapor pressure, we can increase or decrease it until the areas bounded by the original curve and the flat saturation pressure sum to zero. These areas are described by the integral of the pressure over the range of volumes in question, so what we're looking for is \\[ \\int_{V_1}^{V_2} (p - p_s) \\texttt{d}V = 0, \\] or \\[ \\int_{V_1}^{V_s} (p - p_s) \\texttt{d}V + \\int_{V_s}^{V_2} (p - p_s) \\texttt{d}V = 0, \\] where $p_s = p(V_s) $ is the saturation vapor pressure and \\(V_1\\) and \\(V_2\\) are, respectively, the minimum and maximum volumes at which \\((p(V) = p_s\\) in the original Van der Waals pressure curves. These integrals can be approximated using a simple quadrature rule such as the midpoint rule.","title":"Approximating the saturation vapor pressure numerically"},{"location":"example/#exercises_1","text":"Try to implement this iterative scheme to compute the saturation vapor pressure for the above isotherm. (Hint: use an input that specifies a single temperature.) Extra credit: can you add a setting to your program that specifies whether or not to compute the saturation vapor pressure? You can read about settings in the Input Format and API sections. Can you find the critical point for carbon dioxide by exploring various Van der Waals isotherms? How do you know when you've found it?","title":"Exercises"},{"location":"input/","text":"Input Format (YAML) A Skywalker program accepts a YAML file as input. YAML is a simple and expressive language for describing data in a portable format. It offers all of the features of Fortran namelists and more, and it can be used in programs written in any language. Skywalker extracts information from specific variables in your YAML input file. For simplicity, we refer to variables at the top level of a YAML file as blocks , because they resemble block sections in other file formats. Here's an example of a YAML file containing blocks a , b , c , and d : a: This block is just a string b: description: this block is a set of keys and values key1: value1 # (like this!) key2: 112 # (and this!) key3: 3.14159265357 # (and this!) c: [1, 2, 3, 4, 5] # this block is an array of integers d: # this block is the \u0455ame array as c, expressed differently - 1 - 2 - 3 - 4 - 5 As you can see above, lists of values are indicated by comma-separated values surrounded by braces, or a sequence of values prepended by hyphens. Notice also that YAML ignores anything starting with a # character, which allows you to annotate YAML files with comments. Skywalker YAML Input Skywalker looks for the following information in an input file, each of which belongs in its own block: an optional settings block that conveys information from the user to a Skywalker program an input block that defines the members of the ensemble. Here's an example of a Skywalker input file used to test an aerosol parameterization that appears in two different scientific codes: # Computes the rate of binary nucleation as a function of relative humidity [-] # and temperature [K] driver1: # settings for driver1 nucleation_method: 2 pbl_method: 0 driver2: # settings for driver2 name: mer07_veh02_wang08_nuc_1box newnuc_method_user_choice: 2 pbl_nuc_wang2008_user_choice: 0 input: fixed: c_h2so4: 5e8 # [#/cc] planetary_boundary_layer_height: 1100 height: 500 xi_nh3: 0 lattice: relative_humidity: [0.01, 1.00, 0.01] temperature: [230.15, 300.15, 1] Below, we describe the structure of each of these blocks, and give examples. Skywalker parses the input YAML file for you, so there's no need to worry about types, comments, or any of the details of the YAML format. These blocks can appear in any order within a YAML file. A Skywalker program ignores all blocks aside from settings and input blocks. Settings A Skywalker program may need information about how to configure itself, in addition to the information about the ensembles it constructs. If it does, it can specify the name of a block to search for \"settings\". For example, the Skywalker input file in the first section of this page has two settings blocks: driver1 , which is needed by one Skywalker program driver2 , which is needed by a different Skywalker program The ability to tell Skywalker where to look for settings allows you to run several different programs with the same input, and compare their results. This is an invaluable capability for cross validating scientific codes. Notice the structure of the driver1 and driver2 settings blocks. They consist of simple named variables, each with a single value. Skywalker settings are always interpreted as strings, so if your program needs an integer or floating point value to configure itself, it must convert the relevant setting to the correct type. Settings blocks are entirely optional and can be omitted if you don't need them. Input Skywalker looks for parameter values in a input block. There are three types of parameters that define an ensemble: fixed : A fixed parameter assumes a single value for every member of an ensemble. lattice : A lattice parameter is a parameter that assumes several values over different ensemble members and is combined with all other lattice parameters to form a lattice spanned by the ensemble. When Skywalker constructs an ensemble, it takes the outer product of all values for lattice parameters. In everyday language, this means that there exists an ensemble member for every possible combination of all lattice parameters. For example, a lattice of 3 parameters each assuming 10 values creates an ensemble of \\(10\\times10\\times10 = 1000\\) members. The order in which parameter values are specified is not specified or controllable. enumerated : An enumerated parmeter adopts a specific set of values in tandem with all other enumerated parameters in lockstep, to construct ensemble members that have these values. The first ensemble member assumes the first specified value of each parameter, a second member assumes the second value of each, and so on. All ensemble parameters must have the same number of values. For example, in an ensemble consisting a set of enumerated parameters with 1000 members, every parameter must assume 1000 values. Look at the input block in the above example. There are 8 parameters: 4 fixed parameters and 4 lattice parameters. The fixed parameters assume a single value, and the lattice parameters assume several values. You can easily construct an ensemble using a combination of lattice and enumerated parameters. To figure out the number of members in such an ensemble, simply multiply the number of members in the generated lattice by the number of enumerated values in any of the ensemble parameters. Lists of Parameter Values and Uniform Spacing There are a few ways to specify multiple values for a parameter. The simplest way is to list the values exhaustively. For example, if we want to study the behavior of our binary nucleation parameterization between temperatures of 230.15 K and 300.15 K, in increments of 1 K, we can write input: ... temperature: [230.15, 231.15, 232.15, 233.15, ..., 298.15, 299.15, 300.15] ... where we have replaced several terms with ellipsis for brevity. This is simple but cumbersome, especially since we are using a uniform step size. A much easier way to do the same thing is to use the form of the temperature parameter in the above example, which uses a 3-value list to specify the same set of values: input: ... temperature: [230.15, 300.15, 1] ... This reads: \"the temperature parameter assumes values from 230.15 to 300.15, including the endpoints, in uniform steps of 1.\" How does Skywalker know this isn't a list containing the temperatures 230.15 K, 300.15 K, and 1 K? It uses a set of simple rules to determine how to interpret these values. A list with values \\(\\[v_1, v_2, v_3\\]\\) that satisfies the following properties is expanded into a uniformly spaced set of values between \\(v_1\\) and \\(v_2\\) with spacing \\(v_3\\) : \\(v_1 < v_2\\) \\(0 < v_3 < v_2\\) or \\(v_2 < 0\\) and \\(0 < v_3 < (v_2 - v_1)/2\\) All other lists are interpreted as lists containing 3 values. These rules handle most cases of interest, but there remain some sequences that suggest expan\u0455ion but that Skywalker does not expand. Examples For example, the list [-11, 1, 2] could be interpreted as the uniformly-spaced set of values [-11, -9, -7, -5, -3, -1, 1] , but since \\(2 > 1\\) and \\(1 > 0\\) , Skywalker doesn't expand it. Some other examples: The list [0, 1, 0.1] expands to [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1] . The list [-2, 0, 0.2] is not expanded. The list [-2, 1, 0.25] expands to [-2, -1.75, -1.5, -1.25, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1] . The list [-10, -1, 1] expands to [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1] . The list [-11, 1, 1] is not expanded. The list [-11, 1, 2] is not expanded. The list [-7, 2, 1] expands to [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2] . Because this expan\u0455ion feature is intended as a convenience, you can always explicitly perform the expan\u0455ion yourself when you create an input file. Logarithmic Spacing Sometimes a parameter varies over several orders of magnitude, making it inconvenient to specify uniformly-spaced values. For example, chemical reactions can exhibit different behaviors over large ranges of number concentrations in their reactants. For these situations, Skywalker offers an elegant solution that allows you to define the values for a such a parameter on a logarithmic scale. Simply \"take the log of\" the entry for your parameter: input: ... log10(c_h2so4): [10, 12, 0.05] ... The above list assigns values to the parameter c_h2so4 between \\(10^{10}\\) and \\(10^{12}\\) , using \\((12 - 10)/0.05 = 40\\) uniformly-spaced points on a logarithmic scale. You can use this logarithmic option for parameters with explicitly listed values as well, but it's most u\u0455eful when combined with the uniform spacing above. Array-Valued Parameters Occasionally, it's useful to use a single parameter name for a collection of values. For example, the concentrations in a miscible fluid can be considered the components of a single variable, as long as their ordering is well defined. Here, Skywalker takes advantage of the flexibility in the YAML format. Suppose you have a variable densities representing the various densities in a fluid mixture, and that there are 3 components. Here's how you would specify 4 different configurations of the fluid's concentrations: input: fixed: densities: [1e-5, 1e-9, 1e-7] ... In addition, you can also define lattice parameters that are arrays, such as: input: lattice: current_gas_mix_ratios: [[0.1, 0.3, 0.6], [0, 0.4, 0.4], [0.2, 0.8, 0], [0.5, 0.25, 0.25]] Here, we have used two sets of braces (a \"list of lists\") to indicate that the parameter current_gas_mix_ratios assumes 4 values, each of which is a list of 3 numbers. This is a very powerful syntax, but it comes with \u0455ome caveats: You can't use logarithmic spacing options with array parameters Skywalker makes no attempt to verify that all values in a list of array parameters have the same length The three-parameter uniform spacing option is also available to array parameters: input: ... lattice: wet_geo_mean_diameter: [[0.001, 0.002, 0.003],[0.004, 0.005, 0.009], [0.001, 0.001, 0.002]] ... In the input above, the wet_geo_mean_diameter parameter assumes an array value with uniform spacing for each ensemble. The array values start at [0.001, 0.002, 0.003] and go to [0.004, 0.005, 0.009] , incrementing each individual array entry by [0.001, 0.001, 0.002] for each ensemble. The interpretation of the values as a uniform spacing list is the same as above for a scalar list: The list contains 3 arrays Each value in the first list is less than the corresponding value in the second list Each value in the third list is less than the corresponding value in the second list All other lists are interpreted as lists containing 3 lists. Use array-valued parameters with caution.","title":"Input Format (YAML)"},{"location":"input/#input-format-yaml","text":"A Skywalker program accepts a YAML file as input. YAML is a simple and expressive language for describing data in a portable format. It offers all of the features of Fortran namelists and more, and it can be used in programs written in any language. Skywalker extracts information from specific variables in your YAML input file. For simplicity, we refer to variables at the top level of a YAML file as blocks , because they resemble block sections in other file formats. Here's an example of a YAML file containing blocks a , b , c , and d : a: This block is just a string b: description: this block is a set of keys and values key1: value1 # (like this!) key2: 112 # (and this!) key3: 3.14159265357 # (and this!) c: [1, 2, 3, 4, 5] # this block is an array of integers d: # this block is the \u0455ame array as c, expressed differently - 1 - 2 - 3 - 4 - 5 As you can see above, lists of values are indicated by comma-separated values surrounded by braces, or a sequence of values prepended by hyphens. Notice also that YAML ignores anything starting with a # character, which allows you to annotate YAML files with comments.","title":"Input Format (YAML)"},{"location":"input/#skywalker-yaml-input","text":"Skywalker looks for the following information in an input file, each of which belongs in its own block: an optional settings block that conveys information from the user to a Skywalker program an input block that defines the members of the ensemble. Here's an example of a Skywalker input file used to test an aerosol parameterization that appears in two different scientific codes: # Computes the rate of binary nucleation as a function of relative humidity [-] # and temperature [K] driver1: # settings for driver1 nucleation_method: 2 pbl_method: 0 driver2: # settings for driver2 name: mer07_veh02_wang08_nuc_1box newnuc_method_user_choice: 2 pbl_nuc_wang2008_user_choice: 0 input: fixed: c_h2so4: 5e8 # [#/cc] planetary_boundary_layer_height: 1100 height: 500 xi_nh3: 0 lattice: relative_humidity: [0.01, 1.00, 0.01] temperature: [230.15, 300.15, 1] Below, we describe the structure of each of these blocks, and give examples. Skywalker parses the input YAML file for you, so there's no need to worry about types, comments, or any of the details of the YAML format. These blocks can appear in any order within a YAML file. A Skywalker program ignores all blocks aside from settings and input blocks.","title":"Skywalker YAML Input"},{"location":"input/#settings","text":"A Skywalker program may need information about how to configure itself, in addition to the information about the ensembles it constructs. If it does, it can specify the name of a block to search for \"settings\". For example, the Skywalker input file in the first section of this page has two settings blocks: driver1 , which is needed by one Skywalker program driver2 , which is needed by a different Skywalker program The ability to tell Skywalker where to look for settings allows you to run several different programs with the same input, and compare their results. This is an invaluable capability for cross validating scientific codes. Notice the structure of the driver1 and driver2 settings blocks. They consist of simple named variables, each with a single value. Skywalker settings are always interpreted as strings, so if your program needs an integer or floating point value to configure itself, it must convert the relevant setting to the correct type. Settings blocks are entirely optional and can be omitted if you don't need them.","title":"Settings"},{"location":"input/#input","text":"Skywalker looks for parameter values in a input block. There are three types of parameters that define an ensemble: fixed : A fixed parameter assumes a single value for every member of an ensemble. lattice : A lattice parameter is a parameter that assumes several values over different ensemble members and is combined with all other lattice parameters to form a lattice spanned by the ensemble. When Skywalker constructs an ensemble, it takes the outer product of all values for lattice parameters. In everyday language, this means that there exists an ensemble member for every possible combination of all lattice parameters. For example, a lattice of 3 parameters each assuming 10 values creates an ensemble of \\(10\\times10\\times10 = 1000\\) members. The order in which parameter values are specified is not specified or controllable. enumerated : An enumerated parmeter adopts a specific set of values in tandem with all other enumerated parameters in lockstep, to construct ensemble members that have these values. The first ensemble member assumes the first specified value of each parameter, a second member assumes the second value of each, and so on. All ensemble parameters must have the same number of values. For example, in an ensemble consisting a set of enumerated parameters with 1000 members, every parameter must assume 1000 values. Look at the input block in the above example. There are 8 parameters: 4 fixed parameters and 4 lattice parameters. The fixed parameters assume a single value, and the lattice parameters assume several values. You can easily construct an ensemble using a combination of lattice and enumerated parameters. To figure out the number of members in such an ensemble, simply multiply the number of members in the generated lattice by the number of enumerated values in any of the ensemble parameters.","title":"Input"},{"location":"input/#lists-of-parameter-values-and-uniform-spacing","text":"There are a few ways to specify multiple values for a parameter. The simplest way is to list the values exhaustively. For example, if we want to study the behavior of our binary nucleation parameterization between temperatures of 230.15 K and 300.15 K, in increments of 1 K, we can write input: ... temperature: [230.15, 231.15, 232.15, 233.15, ..., 298.15, 299.15, 300.15] ... where we have replaced several terms with ellipsis for brevity. This is simple but cumbersome, especially since we are using a uniform step size. A much easier way to do the same thing is to use the form of the temperature parameter in the above example, which uses a 3-value list to specify the same set of values: input: ... temperature: [230.15, 300.15, 1] ... This reads: \"the temperature parameter assumes values from 230.15 to 300.15, including the endpoints, in uniform steps of 1.\" How does Skywalker know this isn't a list containing the temperatures 230.15 K, 300.15 K, and 1 K? It uses a set of simple rules to determine how to interpret these values. A list with values \\(\\[v_1, v_2, v_3\\]\\) that satisfies the following properties is expanded into a uniformly spaced set of values between \\(v_1\\) and \\(v_2\\) with spacing \\(v_3\\) : \\(v_1 < v_2\\) \\(0 < v_3 < v_2\\) or \\(v_2 < 0\\) and \\(0 < v_3 < (v_2 - v_1)/2\\) All other lists are interpreted as lists containing 3 values. These rules handle most cases of interest, but there remain some sequences that suggest expan\u0455ion but that Skywalker does not expand.","title":"Lists of Parameter Values and Uniform Spacing"},{"location":"input/#examples","text":"For example, the list [-11, 1, 2] could be interpreted as the uniformly-spaced set of values [-11, -9, -7, -5, -3, -1, 1] , but since \\(2 > 1\\) and \\(1 > 0\\) , Skywalker doesn't expand it. Some other examples: The list [0, 1, 0.1] expands to [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1] . The list [-2, 0, 0.2] is not expanded. The list [-2, 1, 0.25] expands to [-2, -1.75, -1.5, -1.25, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1] . The list [-10, -1, 1] expands to [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1] . The list [-11, 1, 1] is not expanded. The list [-11, 1, 2] is not expanded. The list [-7, 2, 1] expands to [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2] . Because this expan\u0455ion feature is intended as a convenience, you can always explicitly perform the expan\u0455ion yourself when you create an input file.","title":"Examples"},{"location":"input/#logarithmic-spacing","text":"Sometimes a parameter varies over several orders of magnitude, making it inconvenient to specify uniformly-spaced values. For example, chemical reactions can exhibit different behaviors over large ranges of number concentrations in their reactants. For these situations, Skywalker offers an elegant solution that allows you to define the values for a such a parameter on a logarithmic scale. Simply \"take the log of\" the entry for your parameter: input: ... log10(c_h2so4): [10, 12, 0.05] ... The above list assigns values to the parameter c_h2so4 between \\(10^{10}\\) and \\(10^{12}\\) , using \\((12 - 10)/0.05 = 40\\) uniformly-spaced points on a logarithmic scale. You can use this logarithmic option for parameters with explicitly listed values as well, but it's most u\u0455eful when combined with the uniform spacing above.","title":"Logarithmic Spacing"},{"location":"input/#array-valued-parameters","text":"Occasionally, it's useful to use a single parameter name for a collection of values. For example, the concentrations in a miscible fluid can be considered the components of a single variable, as long as their ordering is well defined. Here, Skywalker takes advantage of the flexibility in the YAML format. Suppose you have a variable densities representing the various densities in a fluid mixture, and that there are 3 components. Here's how you would specify 4 different configurations of the fluid's concentrations: input: fixed: densities: [1e-5, 1e-9, 1e-7] ... In addition, you can also define lattice parameters that are arrays, such as: input: lattice: current_gas_mix_ratios: [[0.1, 0.3, 0.6], [0, 0.4, 0.4], [0.2, 0.8, 0], [0.5, 0.25, 0.25]] Here, we have used two sets of braces (a \"list of lists\") to indicate that the parameter current_gas_mix_ratios assumes 4 values, each of which is a list of 3 numbers. This is a very powerful syntax, but it comes with \u0455ome caveats: You can't use logarithmic spacing options with array parameters Skywalker makes no attempt to verify that all values in a list of array parameters have the same length The three-parameter uniform spacing option is also available to array parameters: input: ... lattice: wet_geo_mean_diameter: [[0.001, 0.002, 0.003],[0.004, 0.005, 0.009], [0.001, 0.001, 0.002]] ... In the input above, the wet_geo_mean_diameter parameter assumes an array value with uniform spacing for each ensemble. The array values start at [0.001, 0.002, 0.003] and go to [0.004, 0.005, 0.009] , incrementing each individual array entry by [0.001, 0.001, 0.002] for each ensemble. The interpretation of the values as a uniform spacing list is the same as above for a scalar list: The list contains 3 arrays Each value in the first list is less than the corresponding value in the second list Each value in the third list is less than the corresponding value in the second list All other lists are interpreted as lists containing 3 lists. Use array-valued parameters with caution.","title":"Array-Valued Parameters"},{"location":"installation/","text":"Installation We've tried to make Skywalker as easy as possible to use with your current software. To build it, you need CMake v3.10+ GNU Make Reliable C and C++ compilers (like GCC and Clang) A decent Fortran compiler (like GFortran or Intel's ifort ) You can also build Skywalker on Windows. It has been tested with Visual Studio 2022 Community Edition with the Intel oneAPI Fortran Class\u0456c ( ifort ) compiler. Your mileage may vary if you use different versions of Visual Studio or a different Fortran compiler. Clone the Repository First, go get the source code at GitHub: SSH HTTPS git clone git@github.com:eagles-project/skywalker.git git clone https://github.com/eagles-project/skywalker.git This places a skywalker folder into your current path. If you're using Visual Studio, just use your Git workflow to clone the repository. Configure Skywalker Skywalker uses CMake as its build system. CMake accepts a few options that specify how Skywalker should be built. Here are the most important options for you to consider. CMAKE_INSTALL_PREFIX sets the path to which the Skywalker C, C++, and Fortran headers/module and libraries are installed. This is often something like /usr/local by default. CMAKE_BUILD_TYPE controls whether optimization is on ( Release ) or whether the build is instrumented for a debugger ( Debug ). SKYWALKER_PRECISION can be set to single or double (default) to control the precision of floating point numbers. CMAKE_C_COMPILER sets the C compiler that is used to build Skywalker. Usually, the default compiler is fine, but if you want to use an MPI-capable compiler or a specific vendor compiler, you can specify it with this option. CMAKE_Fortran_COMPILER sets the Fortran compiler that is used to build Skywalker's Fortran interface. Linux/Mac Windows From the top-level skywalker directory, create a \"build\" directory (e.g. build ). This is where you'll configure and build Skywalker. For example, to configure a debuggable build of Skywalker that uses double precision, do the following: mkdir build cd build cmake -DCMAKE_INSTALL_PREFIX=/path/to/install \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSKYWALKER_PRECISION=double \\ .. This creates a set of Makefile s in your build directory. Now you're ready to build. Visual Studio gets its settings from CMakeSettings.json in the top-level source directory. Build, Test, and Install Skywalker Linux/Mac Windows To build skywalker, make sure you're in your build directory and type make -j If this process succeeds, you can run the tests and examples included with Skywalker by typing make test If you're using Linux, you can also run Skywalker's tests through Valgrind to check for memory corruptions and leaks with make memcheck (but be prepared to wait a while for the tests to finish). You should see several tests run (and hopefully pass!). Now, to install Skywalker to the path you specified with CMAKE_INSTALL_PREFIX , type make install You should be able to use the Build and Test workflows in Visual Studio to build, test, and install Skywalker. The installation process produces the following artifacts, which you can use to build your own Skywalker programs: PREFIX/lib/libskywalker_<precision>.a , a library you can use with a C or C++ Skywalker program. PREFIX/lib/libskywalker_f90_<precision>.a , a library you can use with a Fortran Skywalker program. PREFIX/include/skywalker.h , a C header file that provides Skywalker's C interface. PREFIX/include/skywalker.hpp , a C++ header file that provides Skywalker's C++ interface. PREFIX/include/skywalker.mod , a Fortran 90 module header file that provides Skywalker's Fortran interface. PREFIX/share/skywalker.cmake , a CMake file that includes installation information for Skywalker, plus a function called add_skywalker_driver you can use to build your own driver programs. On Windows, the library files have a .lib suffix instead of .a . Here, PREFIX stands for the path you passed to CMAKE_INSTALL_PREFIX . These files are all you need to build Skywalker programs. Try It Out! At this point, you're ready to start using Skywalker. Look at the Quick Start section to get started.","title":"Installation"},{"location":"installation/#installation","text":"We've tried to make Skywalker as easy as possible to use with your current software. To build it, you need CMake v3.10+ GNU Make Reliable C and C++ compilers (like GCC and Clang) A decent Fortran compiler (like GFortran or Intel's ifort ) You can also build Skywalker on Windows. It has been tested with Visual Studio 2022 Community Edition with the Intel oneAPI Fortran Class\u0456c ( ifort ) compiler. Your mileage may vary if you use different versions of Visual Studio or a different Fortran compiler.","title":"Installation"},{"location":"installation/#clone-the-repository","text":"First, go get the source code at GitHub: SSH HTTPS git clone git@github.com:eagles-project/skywalker.git git clone https://github.com/eagles-project/skywalker.git This places a skywalker folder into your current path. If you're using Visual Studio, just use your Git workflow to clone the repository.","title":"Clone the Repository"},{"location":"installation/#configure-skywalker","text":"Skywalker uses CMake as its build system. CMake accepts a few options that specify how Skywalker should be built. Here are the most important options for you to consider. CMAKE_INSTALL_PREFIX sets the path to which the Skywalker C, C++, and Fortran headers/module and libraries are installed. This is often something like /usr/local by default. CMAKE_BUILD_TYPE controls whether optimization is on ( Release ) or whether the build is instrumented for a debugger ( Debug ). SKYWALKER_PRECISION can be set to single or double (default) to control the precision of floating point numbers. CMAKE_C_COMPILER sets the C compiler that is used to build Skywalker. Usually, the default compiler is fine, but if you want to use an MPI-capable compiler or a specific vendor compiler, you can specify it with this option. CMAKE_Fortran_COMPILER sets the Fortran compiler that is used to build Skywalker's Fortran interface. Linux/Mac Windows From the top-level skywalker directory, create a \"build\" directory (e.g. build ). This is where you'll configure and build Skywalker. For example, to configure a debuggable build of Skywalker that uses double precision, do the following: mkdir build cd build cmake -DCMAKE_INSTALL_PREFIX=/path/to/install \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSKYWALKER_PRECISION=double \\ .. This creates a set of Makefile s in your build directory. Now you're ready to build. Visual Studio gets its settings from CMakeSettings.json in the top-level source directory.","title":"Configure Skywalker"},{"location":"installation/#build-test-and-install-skywalker","text":"Linux/Mac Windows To build skywalker, make sure you're in your build directory and type make -j If this process succeeds, you can run the tests and examples included with Skywalker by typing make test If you're using Linux, you can also run Skywalker's tests through Valgrind to check for memory corruptions and leaks with make memcheck (but be prepared to wait a while for the tests to finish). You should see several tests run (and hopefully pass!). Now, to install Skywalker to the path you specified with CMAKE_INSTALL_PREFIX , type make install You should be able to use the Build and Test workflows in Visual Studio to build, test, and install Skywalker. The installation process produces the following artifacts, which you can use to build your own Skywalker programs: PREFIX/lib/libskywalker_<precision>.a , a library you can use with a C or C++ Skywalker program. PREFIX/lib/libskywalker_f90_<precision>.a , a library you can use with a Fortran Skywalker program. PREFIX/include/skywalker.h , a C header file that provides Skywalker's C interface. PREFIX/include/skywalker.hpp , a C++ header file that provides Skywalker's C++ interface. PREFIX/include/skywalker.mod , a Fortran 90 module header file that provides Skywalker's Fortran interface. PREFIX/share/skywalker.cmake , a CMake file that includes installation information for Skywalker, plus a function called add_skywalker_driver you can use to build your own driver programs. On Windows, the library files have a .lib suffix instead of .a . Here, PREFIX stands for the path you passed to CMAKE_INSTALL_PREFIX . These files are all you need to build Skywalker programs.","title":"Build, Test, and Install Skywalker"},{"location":"installation/#try-it-out","text":"At this point, you're ready to start using Skywalker. Look at the Quick Start section to get started.","title":"Try It Out!"},{"location":"output/","text":"Output Format (Python) A Skywalker program writes all of its data (input parameters and output values) to a text file containing a Python module. The data in the Python module is structured in a regular way for easy use by postprocessing scripts. The module contains two Python variables: input , an object whose fields list all of the input parameters specified in the YAML input file, in the order in which they appear in the ensemble created by Skywalker output , an object whose fields list all of the output parameters corresponding to the input paramaters, in the same order as the input parameters. settings (if settings are present), an object whose fields list all of the driver-specific settings used to process the ensemble. All settings fields are strings. Consider the input block from the example input file in the Input Format section: my_settings: method = quadrature input: lattice: relative_humidity: [0.01, 1.00, 0.01] temperature: [230.15, 300.15, 1] fixed: c_h2so4: 5e8 # [#/cc] planetary_boundary_layer_height: 1100 height: 500 xi_nh3: 0 With this input, Skywalker constructs an ensemble whose members assume all possible combinations of its lattice parameters. There are 100 values for relative_humidity , 71 values for temperature , and a single value for all other parameters. So there are \\(100 \\times 71 = 7100\\) members in the resulting lattice ensemble. Suppose our program generates output variables nucleation_rate and nucleation_threshold , both of which depend on some or all of the input parameters. Here's how the resulting Python module might look. # This file was automatically generated by skywalker. from math import nan as nan # Object is just a dynamic container that stores input/output data. class Object(object): pass # Settings are stored here. settings = Object() settings.method = 'quadrature' # Input is stored here. input = Object() input.relative_humidity = [0.01, 0.02, 0.03, ..., 0.98, 0.99, 1.00, ] input.temperature = [230.15, 230.15, 230.15, ..., 300.15, 300.15, 300.15, ] input.c_h2so4 = [5e8, 5e8, 5e8, ..., 5e8, 5e8, 5e8, ] input.planetary_boundary_layer_height = [1100, 1100, 1100, ..., 1100, 1100, 1100, ] input.height = [500, 500, 500, ..., 500, 500, 500, ] # Output data is stored here. output = Object() output.nucleation_rate = [1.56031e+06, 4.00182e+06, 6.14731e+06, ..., 2.75652e-08, 3.8792e-08, 5.44561e-08, ] output.nucleation_threshold = [2.52217e+09, 2.37766e+09, 2.24821e+09, ..., 9.00622e+08, 8.85519e+08, 8.70748e+08, ] We've used ellipsis to omit unnecessary detail. The Object type is just a simple trick to allow us to dynamically create fields for the settings , input , and output variables. The important thing here is that all input and output lists in this module have 7100 values, and these values all appear in the same order. The first value in each list belongs to the first member of the ensemble, the second value to the second member, and so on, up to the last value in each list, which belongs to the last ensemble member. This allows you to write postprocessing logic that can easily associate input and output variables. You can easily write a postprocessor to do sensitivity analysis, parameter estimation, or comparisons of two or more different algorithms or codes. You can even write a conversion utility that imports the Python module and writes it to another format. For an example of this, take a look at the py2ncl program included with Skywalker. py2ncl converts Skywalker output to a text file that can be used with legacy NCL programs. (The latest version of NCL is adopting Python as its language.) NaNs Sometimes a Skywalker program emits a NaN, either as the result of pathological numeric arithmetic or as an indicator that the value is undefined. In this case, the value is written using Python's nan representation. This ensures a faithful translation for all data, no matter what the circumstance. Array-Valued Outputs Just as you can store multiple values in a single input array parameter, you can write outputs with multiple values stored in an array. And just as input array parameters are indicated with two sets of braces in a YAML input file, output array values are similarly indicated with two sets of braces, even for ensembles having only a single member. The syntax is easy and intuitive, mostly because YAML and Python use the same format for defining lists. Skywalker doesn't impose any structure on array-valued outputs. For example, it's possible to write arrays with different sizes to a single output variable. Therefore, your program must write array-valued outputs in the most sensible way for your work.","title":"Output Format (Python)"},{"location":"output/#output-format-python","text":"A Skywalker program writes all of its data (input parameters and output values) to a text file containing a Python module. The data in the Python module is structured in a regular way for easy use by postprocessing scripts. The module contains two Python variables: input , an object whose fields list all of the input parameters specified in the YAML input file, in the order in which they appear in the ensemble created by Skywalker output , an object whose fields list all of the output parameters corresponding to the input paramaters, in the same order as the input parameters. settings (if settings are present), an object whose fields list all of the driver-specific settings used to process the ensemble. All settings fields are strings. Consider the input block from the example input file in the Input Format section: my_settings: method = quadrature input: lattice: relative_humidity: [0.01, 1.00, 0.01] temperature: [230.15, 300.15, 1] fixed: c_h2so4: 5e8 # [#/cc] planetary_boundary_layer_height: 1100 height: 500 xi_nh3: 0 With this input, Skywalker constructs an ensemble whose members assume all possible combinations of its lattice parameters. There are 100 values for relative_humidity , 71 values for temperature , and a single value for all other parameters. So there are \\(100 \\times 71 = 7100\\) members in the resulting lattice ensemble. Suppose our program generates output variables nucleation_rate and nucleation_threshold , both of which depend on some or all of the input parameters. Here's how the resulting Python module might look. # This file was automatically generated by skywalker. from math import nan as nan # Object is just a dynamic container that stores input/output data. class Object(object): pass # Settings are stored here. settings = Object() settings.method = 'quadrature' # Input is stored here. input = Object() input.relative_humidity = [0.01, 0.02, 0.03, ..., 0.98, 0.99, 1.00, ] input.temperature = [230.15, 230.15, 230.15, ..., 300.15, 300.15, 300.15, ] input.c_h2so4 = [5e8, 5e8, 5e8, ..., 5e8, 5e8, 5e8, ] input.planetary_boundary_layer_height = [1100, 1100, 1100, ..., 1100, 1100, 1100, ] input.height = [500, 500, 500, ..., 500, 500, 500, ] # Output data is stored here. output = Object() output.nucleation_rate = [1.56031e+06, 4.00182e+06, 6.14731e+06, ..., 2.75652e-08, 3.8792e-08, 5.44561e-08, ] output.nucleation_threshold = [2.52217e+09, 2.37766e+09, 2.24821e+09, ..., 9.00622e+08, 8.85519e+08, 8.70748e+08, ] We've used ellipsis to omit unnecessary detail. The Object type is just a simple trick to allow us to dynamically create fields for the settings , input , and output variables. The important thing here is that all input and output lists in this module have 7100 values, and these values all appear in the same order. The first value in each list belongs to the first member of the ensemble, the second value to the second member, and so on, up to the last value in each list, which belongs to the last ensemble member. This allows you to write postprocessing logic that can easily associate input and output variables. You can easily write a postprocessor to do sensitivity analysis, parameter estimation, or comparisons of two or more different algorithms or codes. You can even write a conversion utility that imports the Python module and writes it to another format. For an example of this, take a look at the py2ncl program included with Skywalker. py2ncl converts Skywalker output to a text file that can be used with legacy NCL programs. (The latest version of NCL is adopting Python as its language.)","title":"Output Format (Python)"},{"location":"output/#nans","text":"Sometimes a Skywalker program emits a NaN, either as the result of pathological numeric arithmetic or as an indicator that the value is undefined. In this case, the value is written using Python's nan representation. This ensures a faithful translation for all data, no matter what the circumstance.","title":"NaNs"},{"location":"output/#array-valued-outputs","text":"Just as you can store multiple values in a single input array parameter, you can write outputs with multiple values stored in an array. And just as input array parameters are indicated with two sets of braces in a YAML input file, output array values are similarly indicated with two sets of braces, even for ensembles having only a single member. The syntax is easy and intuitive, mostly because YAML and Python use the same format for defining lists. Skywalker doesn't impose any structure on array-valued outputs. For example, it's possible to write arrays with different sizes to a single output variable. Therefore, your program must write array-valued outputs in the most sensible way for your work.","title":"Array-Valued Outputs"},{"location":"quick_start/","text":"Quick Start Once you've successfully installed Skywalker , it's time to write your first Skywalker program. Sometimes we refer to such a program as a driver , since it's really just a way to run an algorithm or parameterization that we want to study. Let's get started. Step 1: Design an Experiment For simplicity, we are going to study a function of two variables \\[ f(x, y) = y \\sin(x) - x \\cos(y) \\] over the domain \\([-2\\pi, 2\\pi]\\times[\u22122\\pi, 2\\pi]\\) . Our input parameters are \\(x\\) and \\(y\\) , and our output variable is \\(f\\) . We will sample points on a uniform grid of evenly-spaced \\(x\\) and \\(y\\) values. Suppose we want to sample \\(f\\) at 100 \\(x\\) values and 100 \\(y\\) values, tracing out the surface it represents above the euclidean plane. Here's a YAML file that sets up the calculation of \\(f\\) on these \\((x, y)\\) points: surface.yaml 1 2 3 4 input: lattice: x: [-6.2831853, 6.2831853, 0.0628] y: [-6.2831853, 6.2831853, 0.0628] Line 2 indicates that all values of \\(x\\) are combined with all values of \\(y\\) . Lines 3 and 4 define 100 uniformly-spaced values between \\(\u22122\\pi\\) and \\(2\\pi\\) for \\(x\\) and \\(y\\) . You can find detailed explanations of all these things in the Input Format (YAML) section. This YAML input file reflects the design of our experiment. Now we just need a Skywalker program that computes \\(f\\) at each of the points we've specified. Step 2: Write a Skywalker Program A Skywalker program creates an ensemble of complete sets of inputs (in this case, the point \\((x, y)\\) in \\(\\mathbb{R}^2\\) ). Each point represents a member of the ensemble. The program loops over each ensemble members \\((x, y)\\) and computes the output \\(f\\) for it. Finally, it writes all of its ensemble data (all values of \\(x\\) , \\(y\\) , and \\(f\\) ) to a Python module that can be used for postprocessing. The data in the module is ordered in such a way that each output is associated with its inputs. Here's a program that does all of these things, written in C, C++, and Fortran. Pick your favorite language, paste the corresponding code into a text editor, and save it to a file with the indicated name. C (surface.c) C++ (surface.cpp) Fortran (surface.F90) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <skywalker.h> #include <math.h> int main ( int argc , char ** argv ) { // Specify the name of the input file. const char * input_file = \"surface.yaml\" ; // Load the ensemble, exiting if the operation fails. sw_ensemble_result_t load_result = sw_load_ensemble ( input_file , NULL ); if ( load_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } // Iterate over all members of the ensemble. sw_ensemble_t * ensemble = load_result . ensemble ; sw_input_t * input ; sw_output_t * output ; while ( sw_ensemble_next ( ensemble , & input , & output )) { // Fetch input values. sw_input_result_t result = sw_input_get ( input , \"x\" ); if ( result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } sw_real_t x = result . value ; result = sw_input_get ( input , \"y\" ); if ( result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } sw_real_t y = result . value ; // Compute f(x, y). sw_real_t f = y * sin ( x ) - x * cos ( y ); // Store f as an output variable. sw_output_set ( output , \"f\" , f ); } // Write a Python module containing the input/output data. const char * output_file = \"surface.py\" ; sw_write_result_t w_result = sw_ensemble_write ( ensemble , output_file ); if ( w_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } // Clean up. sw_ensemble_free ( ensemble ); return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <skywalker.hpp> #include <cmath> #include <iostream> int main ( int argc , char ** argv ) { // Specify the name of the input file. std :: string input_file = \"surface.yaml\" ; // Load the ensemble, exiting if the operation fails. skywalker :: Ensemble * ensemble = nullptr ; try { ensemble = skywalker :: load_ensemble ( input_file ); // Iterate over all members of the ensemble. We define a lambda function // that operates on the input and output variables for each member. ensemble -> process ([]( const skywalker :: Input & input , skywalker :: Output & output ) { // Fetch input values. skywalker :: Real x = input . get ( \"x\" ); skywalker :: Real y = input . get ( \"y\" ); // Compute f(x, y). skywalker :: Real f = y * std :: sin ( x ) - x * std :: cos ( y ); // Store f as an output variable. output . set ( \"f\" , f ); }); // Write a Python module containing the input/output data. std :: string output_file = \"surface.py\" ; ensemble -> write ( output_file ); // Clean up. delete ensemble ; } catch ( skywalker :: Exception & e ) { std :: cerr << \"Error: \" << e . what () << std :: endl ; exit ( -1 ); } return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 program surface use skywalker implicit none character ( len = 255 ) :: input_file , output_file type ( ensemble_result_t ) :: load_result type ( ensemble_t ) :: ensemble type ( input_t ) :: input type ( output_t ) :: output real ( swp ) :: x , y , f ! Specify the name of the input file. input_file = \"surface.yaml\" ! Load the ensemble, exiting if the operation fails. load_result = load_ensemble ( trim ( input_file )) if ( load_result % error_code /= SW_SUCCESS ) then print * , \"Error: \" , trim ( load_result % error_message ) stop end if ! Iterate over all members of the ensemble. ensemble = load_result % ensemble do while ( ensemble % next ( input , output )) ! Fetch inputs. x = input % get ( \"x\" ) y = input % get ( \"y\" ) ! Compute f(x, y). f = y * sin ( x ) - x * cos ( y ) ! Store f as an output variable. call output % set ( \"f\" , f ); end do ! Write out a Python module. output_file = \"surface.py\" call ensemble % write ( output_file ) ! Clean up. call ensemble % free (); end program The API section discusses each of the elements in this program. For now, let's just try to build it and run it. Step 3: Build the Program Everyone has their own setup for building programs, so let's keep it simple: we'll compile the program and link it against the appropriate Skywalker library (or libraries) in one step: C C++ Fortran cc surface.c -I/path/to/include -L/path/to/lib -lskywalker_double -o surface c++ surface.cpp -std=c++11 -I/path/to/include -L/path/to/lib -lskywalker_double -o surface gfortran surface.F90 -I/path/to/include -L/path/to/lib -lskywalker_f90_double -lskywalker_double -o surface If you use a different compiler, substitute it above. A few things to note: The C++ Skywalker program uses lambda functions, which requires at least C++11. The -I flags above indicate the location of the Skywalker headers ( skywalker.h , skywalker.hpp ) and modules ( skywalker.mod ) you installed in the Installation section. So if you set Skywalker's CMAKE_INSTALL_PREFIX to /usr/local , you would use -I/usr/local/include . Likewise, the -L flags tell the linker where to find the Skywalker libraries. If your CMAKE_INSTALL_PREFIX is /usr/local , indicate this with -L/usr/local/lib . The -l parameter indicates the library to link your program against. C and C++ programs must be linked against libskywalker_double.a , while Fortran programs must additionally use libskywalker_f90_double.a . If you've configured Skywalker to use single precision floating point numbers with -DSKYWALKER_PRECISION=single , replace double with single . If all goes well, you'll end up with a surface executable. Step 4: Run the Experiment Now it's time to see the program in action. Make sure your surface executable is in the same directory as your surface.yaml input file, and run it without arguments: ./surface Hopefully, the program runs to completion, generating a surface.py text file containing the data. You can open up this file in an editor to see how it looks. The format of this file is described here . Step 5: Analyze the Results Here's a simple Python 3 program you can run in the same directory as your surface.py file to generate a surface plot of \\(f(x, y)\\) over the domain \\([-2\\pi, 2\\pi] \\times [-2\\pi, 2\\pi]\\) . plot_surface.py import matplotlib.pyplot as plt import numpy as np # Extract data from surface.py. import surface x = np . array ( surface . input . x ) y = np . array ( surface . input . y ) f = np . array ( surface . output . f ) # Plot the contours of f(x, y). plt . tricontour ( x , y , f ) plt . colorbar () # Display the plot. plt . show () The script uses matplotlib , which you can often install with a command like pip3 install matplotlib Run the script to see the plot. python3 plot_surface.py Here's how it looks: That's it. Congratulations--you've successfully used Skywalker to sample a multivariate function over regularly spaced intervals. If you like, you can continue through the rest of the documentation to learn how things work. You can also take a look at a more involved example if that's your style.","title":"Quick Start"},{"location":"quick_start/#quick-start","text":"Once you've successfully installed Skywalker , it's time to write your first Skywalker program. Sometimes we refer to such a program as a driver , since it's really just a way to run an algorithm or parameterization that we want to study. Let's get started.","title":"Quick Start"},{"location":"quick_start/#step-1-design-an-experiment","text":"For simplicity, we are going to study a function of two variables \\[ f(x, y) = y \\sin(x) - x \\cos(y) \\] over the domain \\([-2\\pi, 2\\pi]\\times[\u22122\\pi, 2\\pi]\\) . Our input parameters are \\(x\\) and \\(y\\) , and our output variable is \\(f\\) . We will sample points on a uniform grid of evenly-spaced \\(x\\) and \\(y\\) values. Suppose we want to sample \\(f\\) at 100 \\(x\\) values and 100 \\(y\\) values, tracing out the surface it represents above the euclidean plane. Here's a YAML file that sets up the calculation of \\(f\\) on these \\((x, y)\\) points: surface.yaml 1 2 3 4 input: lattice: x: [-6.2831853, 6.2831853, 0.0628] y: [-6.2831853, 6.2831853, 0.0628] Line 2 indicates that all values of \\(x\\) are combined with all values of \\(y\\) . Lines 3 and 4 define 100 uniformly-spaced values between \\(\u22122\\pi\\) and \\(2\\pi\\) for \\(x\\) and \\(y\\) . You can find detailed explanations of all these things in the Input Format (YAML) section. This YAML input file reflects the design of our experiment. Now we just need a Skywalker program that computes \\(f\\) at each of the points we've specified.","title":"Step 1: Design an Experiment"},{"location":"quick_start/#step-2-write-a-skywalker-program","text":"A Skywalker program creates an ensemble of complete sets of inputs (in this case, the point \\((x, y)\\) in \\(\\mathbb{R}^2\\) ). Each point represents a member of the ensemble. The program loops over each ensemble members \\((x, y)\\) and computes the output \\(f\\) for it. Finally, it writes all of its ensemble data (all values of \\(x\\) , \\(y\\) , and \\(f\\) ) to a Python module that can be used for postprocessing. The data in the module is ordered in such a way that each output is associated with its inputs. Here's a program that does all of these things, written in C, C++, and Fortran. Pick your favorite language, paste the corresponding code into a text editor, and save it to a file with the indicated name. C (surface.c) C++ (surface.cpp) Fortran (surface.F90) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <skywalker.h> #include <math.h> int main ( int argc , char ** argv ) { // Specify the name of the input file. const char * input_file = \"surface.yaml\" ; // Load the ensemble, exiting if the operation fails. sw_ensemble_result_t load_result = sw_load_ensemble ( input_file , NULL ); if ( load_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } // Iterate over all members of the ensemble. sw_ensemble_t * ensemble = load_result . ensemble ; sw_input_t * input ; sw_output_t * output ; while ( sw_ensemble_next ( ensemble , & input , & output )) { // Fetch input values. sw_input_result_t result = sw_input_get ( input , \"x\" ); if ( result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } sw_real_t x = result . value ; result = sw_input_get ( input , \"y\" ); if ( result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } sw_real_t y = result . value ; // Compute f(x, y). sw_real_t f = y * sin ( x ) - x * cos ( y ); // Store f as an output variable. sw_output_set ( output , \"f\" , f ); } // Write a Python module containing the input/output data. const char * output_file = \"surface.py\" ; sw_write_result_t w_result = sw_ensemble_write ( ensemble , output_file ); if ( w_result . error_code != SW_SUCCESS ) { fprintf ( stderr , \"Error: %s\" , load_result . error_message ); exit ( -1 ); } // Clean up. sw_ensemble_free ( ensemble ); return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <skywalker.hpp> #include <cmath> #include <iostream> int main ( int argc , char ** argv ) { // Specify the name of the input file. std :: string input_file = \"surface.yaml\" ; // Load the ensemble, exiting if the operation fails. skywalker :: Ensemble * ensemble = nullptr ; try { ensemble = skywalker :: load_ensemble ( input_file ); // Iterate over all members of the ensemble. We define a lambda function // that operates on the input and output variables for each member. ensemble -> process ([]( const skywalker :: Input & input , skywalker :: Output & output ) { // Fetch input values. skywalker :: Real x = input . get ( \"x\" ); skywalker :: Real y = input . get ( \"y\" ); // Compute f(x, y). skywalker :: Real f = y * std :: sin ( x ) - x * std :: cos ( y ); // Store f as an output variable. output . set ( \"f\" , f ); }); // Write a Python module containing the input/output data. std :: string output_file = \"surface.py\" ; ensemble -> write ( output_file ); // Clean up. delete ensemble ; } catch ( skywalker :: Exception & e ) { std :: cerr << \"Error: \" << e . what () << std :: endl ; exit ( -1 ); } return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 program surface use skywalker implicit none character ( len = 255 ) :: input_file , output_file type ( ensemble_result_t ) :: load_result type ( ensemble_t ) :: ensemble type ( input_t ) :: input type ( output_t ) :: output real ( swp ) :: x , y , f ! Specify the name of the input file. input_file = \"surface.yaml\" ! Load the ensemble, exiting if the operation fails. load_result = load_ensemble ( trim ( input_file )) if ( load_result % error_code /= SW_SUCCESS ) then print * , \"Error: \" , trim ( load_result % error_message ) stop end if ! Iterate over all members of the ensemble. ensemble = load_result % ensemble do while ( ensemble % next ( input , output )) ! Fetch inputs. x = input % get ( \"x\" ) y = input % get ( \"y\" ) ! Compute f(x, y). f = y * sin ( x ) - x * cos ( y ) ! Store f as an output variable. call output % set ( \"f\" , f ); end do ! Write out a Python module. output_file = \"surface.py\" call ensemble % write ( output_file ) ! Clean up. call ensemble % free (); end program The API section discusses each of the elements in this program. For now, let's just try to build it and run it.","title":"Step 2: Write a Skywalker Program"},{"location":"quick_start/#step-3-build-the-program","text":"Everyone has their own setup for building programs, so let's keep it simple: we'll compile the program and link it against the appropriate Skywalker library (or libraries) in one step: C C++ Fortran cc surface.c -I/path/to/include -L/path/to/lib -lskywalker_double -o surface c++ surface.cpp -std=c++11 -I/path/to/include -L/path/to/lib -lskywalker_double -o surface gfortran surface.F90 -I/path/to/include -L/path/to/lib -lskywalker_f90_double -lskywalker_double -o surface If you use a different compiler, substitute it above. A few things to note: The C++ Skywalker program uses lambda functions, which requires at least C++11. The -I flags above indicate the location of the Skywalker headers ( skywalker.h , skywalker.hpp ) and modules ( skywalker.mod ) you installed in the Installation section. So if you set Skywalker's CMAKE_INSTALL_PREFIX to /usr/local , you would use -I/usr/local/include . Likewise, the -L flags tell the linker where to find the Skywalker libraries. If your CMAKE_INSTALL_PREFIX is /usr/local , indicate this with -L/usr/local/lib . The -l parameter indicates the library to link your program against. C and C++ programs must be linked against libskywalker_double.a , while Fortran programs must additionally use libskywalker_f90_double.a . If you've configured Skywalker to use single precision floating point numbers with -DSKYWALKER_PRECISION=single , replace double with single . If all goes well, you'll end up with a surface executable.","title":"Step 3: Build the Program"},{"location":"quick_start/#step-4-run-the-experiment","text":"Now it's time to see the program in action. Make sure your surface executable is in the same directory as your surface.yaml input file, and run it without arguments: ./surface Hopefully, the program runs to completion, generating a surface.py text file containing the data. You can open up this file in an editor to see how it looks. The format of this file is described here .","title":"Step 4: Run the Experiment"},{"location":"quick_start/#step-5-analyze-the-results","text":"Here's a simple Python 3 program you can run in the same directory as your surface.py file to generate a surface plot of \\(f(x, y)\\) over the domain \\([-2\\pi, 2\\pi] \\times [-2\\pi, 2\\pi]\\) . plot_surface.py import matplotlib.pyplot as plt import numpy as np # Extract data from surface.py. import surface x = np . array ( surface . input . x ) y = np . array ( surface . input . y ) f = np . array ( surface . output . f ) # Plot the contours of f(x, y). plt . tricontour ( x , y , f ) plt . colorbar () # Display the plot. plt . show () The script uses matplotlib , which you can often install with a command like pip3 install matplotlib Run the script to see the plot. python3 plot_surface.py Here's how it looks: That's it. Congratulations--you've successfully used Skywalker to sample a multivariate function over regularly spaced intervals. If you like, you can continue through the rest of the documentation to learn how things work. You can also take a look at a more involved example if that's your style.","title":"Step 5: Analyze the Results"}]}