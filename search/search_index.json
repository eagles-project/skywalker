{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Skywalker is a software library that allows you to construct and execute a program on an ensemble: a collection of sets of input parameters, each of which completely defines the behavior of the program. Each complete set of input parameters is a member of the ensemble, and your program can associate a set of outputs with each ensemble member.</p> <p>A Skywalker program accepts as input a YAML file that defines an ensemble. It then executes logic on each member of that ensemble, generating output. It collects this output, associating it with the input that produced it, and then writes all data for the entire ensemble into a Python module in a way that allows postprocessing to be easily performed.</p> <p>You can write a Skywalker program in C, C++, or Fortran. The code you'll write looks very similar in each of these languages. Here are some resources for you to use to solve your own problems with a Skywalker program:</p> <ul> <li>The Installation guide shows you how to build and install   Skywalker.</li> <li>The Quick Start guide shows you how to write a basic   Skywalker program.</li> <li>The API guide describes Skywalker's application programming   interface for all three languages.</li> <li>We've provided a detailed example that demonstrates how you can   use Skywalker to investigate a problem.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Skywalker was developed as part of a close collaboration between climate scientists and software engineers as part of an effort to cross validate two implementations of an aerosol microphysics box model. This effort was funded by the Office of Science's Biological and Environmental Research Program as part of the EAGLES project, an effort to improve the treatment of aerosols in E3SM, the Department of Energy's global climate model. The source code is available on GitHub.</p>"},{"location":"api/","title":"The Skywalker API","text":"<p>Skywalker offers a simple interface for writing programs that operate on entire ensembles. You can access everything in this interface by including the correct C/C++ header file or using the appropriate Fortran module in your program.</p> CC++Fortran <pre><code>#include &lt;skywalker.h&gt;\n</code></pre> <pre><code>#include &lt;skywalker.hpp&gt;\n</code></pre> <pre><code>use skywalker\n</code></pre> <p>Skywalker is written in C, and the C interface is the source of truth for the Fortran and C++ bindings. The Fortran <code>skywalker</code> module exposes all the same types and functions as the C interface. The C++ interface wraps all of the C types in a <code>skywalker.hpp</code> header file, exposing then in the <code>skywalker</code> namespace.</p> <p>A Skywalker program typically consists of the following parts:</p> <ol> <li>Ensemble and settings information are loaded from an input YAML file</li> <li>Settings are used to configure the program to run the loaded ensemble</li> <li>One by one, ensemble members are processed by the program. Ensemble input    parameters are retrieved and used to run a simulation, and then ensemble    output parameters are written and stored.</li> <li>The resulting ensemble is written to a Python module. All input and output    parameters are written and stored in a way that allows them to be    programmatically accessed by a postprocessing script.</li> </ol> <p>Here we describe the types and functions you can use to assemble your own Skywalker program.</p>"},{"location":"api/#data-types","title":"Data Types","text":""},{"location":"api/#real-number-type","title":"Real number type","text":"<p>Skywalker supports exactly one value type that stores real-valued ensemble parameters. By default this type is a double-precision floating point number, but it can be configured for single precision with the <code>SKYWALKER_PRECISION</code> CMake variable.</p> CC++Fortran <pre><code>typedef double sw_real_t;\n</code></pre> <pre><code>using Real = sw_real_t;\n</code></pre> <pre><code>! Skywalker precision (swp): real kind used by skywalker\ninteger, parameter :: swp\n</code></pre> <p>In Fortran, the <code>swp</code> kind is used to store input parameters and output values, and is set to either the <code>c_double</code> or <code>c_float</code> interoperable types defined by the Fortran 2003 ISO C bindings.</p> <p>The C interface also defines the following macros:</p> <ul> <li><code>SW_EPSILON</code>: the \"machine epsilon\" value, an upper bound on the relative   relative approximation error due to rounding in floating point arithmetic.   This maps either to <code>FLT_EPSILON</code> or <code>DBL_EPSILON</code> as defined in <code>float.h</code>,   depending on Skywalker's precision.</li> <li><code>SW_MIN</code>: the minimum representable floating point number. Maps to   <code>FLT_MIN</code> or <code>DBL_MIN</code> as defined in <code>float.h</code>.</li> <li><code>SW_MAX</code>: the maximum representable floating point number. Maps to   <code>FLT_MAX</code> or <code>DBL_MAX</code> as defined in <code>float.h</code>.</li> </ul>"},{"location":"api/#interface-types","title":"Interface types","text":"<p>Each of the essential concepts in the library has an associated type.</p> <ul> <li>An Ensemble stores a set of input and output data for each of its members.</li> </ul> CC++Fortran <pre><code>typedef struct sw_ensemble_t sw_ensemble_t;\n</code></pre> <pre><code>class Ensemble final {\npublic:\n// Returns the settings associated with this ensemble.\nconst Settings&amp; settings() const;\n\n// Iterates over all ensemble members, applying the given function f to\n// each input/output pair.\nvoid process(std::function&lt;void(const Input&amp;, Output&amp;)&gt; f);\n\n// Returns the size of the ensemble (number of members).\nsize_t size() const;\n\n// Writes input and output data within the ensemble to a Python module stored\n// in the file with the given name.\nvoid write(const std::string&amp; module_filename) const;\n};\n</code></pre> <pre><code>type :: ensemble_t\ntype(c_ptr)       :: ptr\ninteger(c_size_t) :: size  ! number of members\ncontains\n! Iterates over ensemble members\nprocedure :: next =&gt; ensemble_next\n! Writes a Python module containing input/output data to a file, halting\n! on failure\nprocedure :: write =&gt; ensemble_write\n! Writes a Python module containing input/output data to a file\nprocedure :: write_module =&gt; ensemble_write_module\n! Destroys an ensemble, freeing all allocated resources. Use at the end of\n! a driver program, or when a fatal error has occurred.\nprocedure :: free =&gt; ensemble_free\nend type ensemble_t\n</code></pre> <ul> <li>The Settings type stores configuration data or metadata associated with   your program and how it treats ensemble members. All of these data are strings   that can be retrieved by name.</li> </ul> CC++Fortran <pre><code>typedef struct sw_settings_t sw_settings_t;\n</code></pre> <pre><code>class Settings final {\npublic:\n\n// Returns true if the setting with the given name exists within the given\n// settings instance, false otherwise.\nbool has(const std::string&amp; name) const;\n\n// Retrieves a (string-valued) setting with the given name, throwing an\n// exception if it doesn't exist.\nstd::string get(const std::string&amp; name) const;\n};\n</code></pre> <pre><code>type :: settings_t\ntype(c_ptr) :: ptr, ensemble_ptr\ncontains\n  procedure :: has =&gt; settings_has\nprocedure :: get =&gt; settings_get\nprocedure :: get_param =&gt; settings_get_param\nend type\n</code></pre> <ul> <li>Ensemble member input is stored in a set of named ensemble parameters   within a dedicated type. Input data cannot be modified--it can only be read.</li> </ul> CC++Fortran <pre><code>typedef struct sw_input_t sw_input_t;\n</code></pre> <pre><code>class Input final {\npublic:\nInput();\n\n// Returns true if the input parameter with the given name exists within\n// the given input instance, false otherwise.\nbool has(const std::string&amp; name) const;\n\n// Retrieves a (real-valued) parameter with the given name, throwing an\n// exception if it doesn't exist.\nReal get(const std::string&amp; name) const;\n\n// Returns true if an input array parameter with the given name exists\n// within the given input instance, false otherwise.\nbool has_array(const std::string&amp; name) const;\n\n// Retrieves a (real-valued) array parameter with the given name, throwing\n// an exception if it doesn't exist.\nstd::vector&lt;Real&gt; get_array(const std::string&amp; name) const;\n};\n</code></pre> <pre><code>type :: input_t\ntype(c_ptr) :: ptr, ensemble_ptr\ncontains\n  procedure :: has =&gt; input_has\nprocedure :: get =&gt; input_get\nprocedure :: get_param =&gt; input_get_param\nprocedure :: has_array =&gt; input_has_array\nprocedure :: get_array =&gt; input_get_array\nprocedure :: get_array_param =&gt; input_get_array_param\nend type input_t\n</code></pre> <ul> <li>Ensemble member output is also stored in a set of named ensemble   parameters within a dedicated type. Unlike input data, output ensemble   parameters can only be written.</li> </ul> CC++Fortran <pre><code>typedef struct sw_output_t sw_output_t;\n</code></pre> <pre><code>class Output final {\npublic:\nOutput();\n\n// Sets a (real-valued) parameter with the given name, throwing an\n// exception if not successful.\nvoid set(const std::string&amp; name, Real value) const;\n\n// Sets (real-valued) parameters with the given name, throwing an\n// exception if not successful.\nvoid set(const std::string&amp; name, const std::vector&lt;Real&gt; &amp;values) const;\n};\n</code></pre> <pre><code>type :: output_t\ntype(c_ptr) :: ptr\ncontains\n! Adds a named metric to the output data.\nprocedure :: set =&gt; output_set\n! Adds a vector of named metric to the output data.\nprocedure :: set_array =&gt; output_set_array\nend type output_t\n</code></pre> <p>Notice that many of the Fortran types are actually classes with bound procedures with implementations, indicated by the <code>procedure =&gt; implementation</code> \u0455yntax. Below, we refer to the functions and subroutines that implement the procedures. The examples and tests illustrate how these procedures are invoked, as this syntax is unfortunately not very clear.</p>"},{"location":"api/#result-types","title":"Result types","text":"<p>The C and Fortran interfaces define types that store the results of operations like loading ensembles from input, fetching input parameters, and writing output parameters. These \"result\" types contain information that can be used for handling errors, and each type has <code>result_t</code> at the end of its name.</p>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>The types in Skywalker's C interface contain fields that can be used to properly handle any errors that occur while reading input or constructing ensembles:</p> <ul> <li><code>error_code</code>: an integer that identifies a specific type of error that you   can use to programmatically handle error conditions. The integer can be   compared with the fields in the <code>sw_error_code_t</code> enumerated type in   <code>skywalker.h</code> or the integer parameters defined in the Fortran module.</li> <li><code>error_message</code>: a descriptive error string that can be printed to tell a user   what went wrong</li> </ul> <p>The Fortran interface offers similar result types with these same fields, but also offers \"shorthand\" versions of functions that simply halt the program with the Fortran <code>STOP</code> command when an error occurs.</p> <p>The C++ interface does not define types to store the results of its functions. Instead, it directly returns the data requested, throwing an exception (of type <code>skywalker::Exception</code>, a subclass of <code>std::exception</code>) containing a string description if any issue occurs.</p> <p>The examples and tests in the repository demonstrate how these error handling mechanisms work in their respective languages.</p>"},{"location":"api/#loading-an-ensemble-and-settings","title":"Loading an Ensemble and Settings","text":"<p>You can load an ensemble and settings for your program from a YAML input file with a single function call.</p> CC++Fortran <pre><code>sw_ensemble_result_t sw_load_ensemble(const char *yaml_file,\nconst char *settings_block);\n</code></pre> <pre><code>namespace skywalker {\nEnsemble* load_ensemble(const std::string&amp; yaml_file,\nconst std::string&amp; settings_block = \"\");\n}\n</code></pre> <pre><code>function load_ensemble(yaml_file, settings_block) result(e_result)\ncharacter(len=*), intent(in) :: yaml_file\ncharacter(len=*), intent(in), optional :: settings_block\ntype(ensemble_result_t) :: e_result\nend function\n</code></pre> <ul> <li><code>yaml_file</code> is the name of the YAML input file to be read. It can be   an absolute or relative path to a file on disk.</li> <li><code>settings_block</code> is the name of the block in the YAML file from which settings   are read. This can be the name of your program, or just <code>\"settings\"</code> if you   want a mneumonic name. This argument is optional: If this string is <code>NULL</code> or   blank in C, or not given in C++ or Fortran, Skywalker does not attempt to read   any settings from the file.</li> </ul> <p>Settings can be used to create a single YAML input file that defines ensembles for several Skywalker programs (e.g. for cross validating different methods or models). Each program can define its own settings in a program-specific block whose name is indicated using the <code>settings_block</code> parameter.</p> <p>The C and Fortran interfaces return a result that contains the ensemble and settings, as well as error handling information.</p> CFortran <pre><code>typedef struct sw_ensemble_result_t {\n// The settings associated with the driver program\nsw_settings_t *settings;\n// The ensemble loaded (or NULL on failure)\nsw_ensemble_t *ensemble;\n// An error code indicating any problems encountered loading the ensemble\n// (zero = success, non-zero = failure)\nint error_code;\n// A string describing any error encountered, or NULL if error_code == 0.\nconst char* error_message;\n} sw_ensemble_result_t;\n</code></pre> <pre><code>type :: ensemble_result_t\n! The settings associated with the driver program\ntype(settings_t) :: settings\n! The ensemble loaded (if no error occurred)\ntype(ensemble_t) :: ensemble\n! The ensemble's type\ninteger :: type\n! An error code indicating any problems encountered loading the ensemble\n! (zero = success, non-zero = failure)\ninteger :: error_code\n! A string describing any error encountered, or NULL if error_code == 0.\ncharacter(len=255) :: error_message\nend type ensemble_result_t\n</code></pre> <p>The C++ interface returns a pointer to an <code>Ensemble</code> instance. Settings are available within this instance. If an error occurs, a <code>skywalker::Exception</code> is thrown containing an error message string identical to the <code>error_message</code> field of the result type returned by the C and Fortran interfaces.</p>"},{"location":"api/#applying-program-settings","title":"Applying Program Settings","text":"<p>If your program can run in more than one configuration, you can select a configuration using the data specified in the settings you've loaded. Settings are stored in strings, and you can retrieve a setting by name from the settings variable you've loaded.</p> <p>Settings can be queried with a <code>has</code> function that returns true if a setting with the given name is found and false otherwise.</p> CC++Fortran <pre><code>// Returns true if the setting with the given name exists within the given\n// settings instance, false otherwise.\nbool sw_settings_has(sw_settings_t *settings, const char* name);\n</code></pre> <pre><code>class Settings final {\n...\n// Returns true if the setting with the given name exists within the given\n// settings instance, false otherwise.\nbool has(const std::string&amp; name) const;\n...\n};\n</code></pre> <pre><code>! Returns .true. if the setting with the given name exists within the given\n! settings instance, false otherwise.\nfunction settings_has(settings, name) result(has)\nclass(settings_t), intent(in) :: settings\ncharacter(len=*), intent(in)  :: name\nlogical(c_bool) :: has\nend function\n</code></pre> <p>A setting with the given name can be fetched.</p> CC++Fortran <pre><code>// Retrieves the setting with the given name.\nsw_settings_result_t sw_settings_get(sw_settings_t *settings,\nconst char *name);\n</code></pre> <pre><code>class Settings final {\n...\n// Retrieves a (string-valued) setting with the given name, throwing an\n// exception if it doesn't exist.\nstd::string get(const std::string&amp; name) const {\n...\n};\n</code></pre> <pre><code>! Retrieves the setting with the given name, returning a result that can\n! be checked for errors that occur.\nfunction settings_get_param(settings, name) result(s_result)\nclass(settings_t), intent(in) :: settings\ncharacter(len=*), intent(in)  :: name\ntype(settings_result_t) :: s_result\nend function\n</code></pre> <p>Fetching a setting fails if a setting with the given name doesn't exist. The C and Fortran interfaces define a result type that allows this situation to be handled.</p> CFortran <pre><code>typedef struct sw_setting_result_t {\nconst char* value;         // fetched value (if error_code == 0)\nint error_code;            // error code indicating success or failure\nconst char* error_message; // text description of error\n} sw_settings_result_t;\n</code></pre> <pre><code>type :: settings_result_t\ncharacter(len=255) :: value         ! fetched value (if error_code == 0)\ninteger            :: error_code    ! error code indicating success or failure\ncharacter(len=255) :: error_message ! text description of error\nend type settings_result_t\n</code></pre> <p>On failure, the C++ interface throws a <code>skywalker::Exception</code> with a string description identical to the <code>error_message</code> description in the C and Fortran result types. For brevity, the Fortran interface also offers a function that halts your program if a setting is not found:</p> Fortran <pre><code>! Retrieves the setting with the given name, halting the program if an\n! error occurs.\nfunction settings_get(settings, name) result(str)\nclass(settings_t), intent(in) :: settings\ncharacter(len=*), intent(in)  :: name\ncharacter(len=255) :: str\nend function\n</code></pre>"},{"location":"api/#processing-an-ensemble-member","title":"Processing an Ensemble Member","text":"<p>The bulk of your Skywalker program is concerned with processing each member of an ensemble. To do this, you must</p> <ul> <li>loop over the ensemble, retrieving the input and output variables for each   member</li> <li>read input parameters from the member's input variable</li> <li>use the input parameters to compute output.</li> <li>set the output parameters in the member's output variable</li> </ul>"},{"location":"api/#looping-over-ensemble-members","title":"Looping over ensemble members","text":"<p>Skywalker handles the process of looping over the ensemble for you. In C and Fortran, you can construct a loop that calls a function to get the input and output parameters for each member, terminating when there are no members left.</p> CFortran <pre><code>// Iterates over the inputs and outputs in an ensemble, making them available\n// one at a time for computation. This function returns true once for each\n// member of an ensemble and false once the ensemble's members have been\n// traversed. Use it as a predicate in a while loop in which inputs and outputs\n// are processed.\nbool sw_ensemble_next(sw_ensemble_t *ensemble,\nsw_input_t **input,\nsw_output_t **output);\n</code></pre> <pre><code>! Iterates over the inputs and outputs in an ensemble, making them available\n! one at a time for computation. This function returns true once for each\n! member of an ensemble and false once the ensemble's members have been\n! traversed. Use it as a predicate in a do while loop in which inputs and\n! outputs are processed.\nfunction ensemble_next(ensemble, input, output) result(next)\nclass(ensemble_t), intent(in) :: ensemble\ntype(input_t), intent(out)    :: input\ntype(output_t), intent(out)   :: output\nlogical(c_bool) :: next\nend function\n</code></pre> <p>In C++, you can write your own function that performs the processing, and pass that function to a method on your <code>Ensemble</code> object. This executes your function on the input and output data for each member. The function you define takes a <code>const</code> reference to an <code>Input</code> object and a non-<code>const</code> reference to an <code>Output</code> object, and returns nothing.</p> C++ <pre><code>class Ensemble final {\n...\n// Iterates over all ensemble members, applying the given function f to\n// each input/output pair.\nvoid process(std::function&lt;void(const Input&amp;, Output&amp;)&gt; f);\n...\n};\n</code></pre> <p>The examples and tests illustrate how this is done.</p>"},{"location":"api/#reading-input-parameters","title":"Reading input parameters","text":"<p>To read an input parameter from an ensemble member, you can retrieve its value using its name.</p> <p>It's easy to check whether the ensemble member has a given parameter:</p> CC++Fortran <pre><code>// Returns true if a (scalar) input parameter with the given name exists\n// within the given input instance, false otherwise.\nbool sw_input_has(sw_input_t *input, const char* name);\n</code></pre> <pre><code>class Input final {\n...\n// Returns true if the input parameter with the given name exists within\n// the given input instance, false otherwise.\nbool has(const std::string&amp; name) const;\n...\n};\n</code></pre> <pre><code>! Returns .true. if the input parameter with the given name exists within the\n! given input instance, false otherwise.\nfunction input_has(input, name) result(has)\nclass(input_t), intent(in) :: input\ncharacter(len=*), intent(in)  :: name\nlogical(c_bool) :: has\nend function\n</code></pre> <p>Similarly, it's easy to fetch the parameter:</p> CC++Fortran <pre><code>// Retrieves the (scalar) input parameter with the given name.\nsw_input_result_t sw_input_get(sw_input_t *input, const char *name);\n</code></pre> <pre><code>class Input final {\n...\n// Retrieves a (real-valued) parameter with the given name, throwing an\n// exception if it doesn't exist.\nReal get(const std::string&amp; name) const;\n...\n};\n</code></pre> <pre><code>! Retrieves the input parameter with the given name.\nfunction input_get_param(input, name) result(i_result)\nclass(input_t), intent(in)   :: input\ncharacter(len=*), intent(in) :: name\ntype(input_result_t) :: i_result\nend function\n</code></pre> <p>Fetching a parameter fails if the parameter doesn't exist within the ensemble. The C and Fortran interfaces return a result type that allows you to check whether the operation succeeded.</p> CFortran <pre><code>typedef struct sw_input_result_t {\nsw_real_t value;           // fetched value (if error_code == 0)\nint error_code;            // error code indicating success or failure\nconst char* error_message; // text description of error\n} sw_input_result_t;\n</code></pre> <pre><code>type :: input_result_t\nreal(c_real)       :: value         ! fetched value (if error_code == 0)\ninteger(c_int)     :: error_code    ! error code indicating success or failure\ncharacter(len=255) :: error_message ! text description of error\nend type input_result_t\n</code></pre> <p>In C++, a <code>skywalker::Exception</code> is thrown in the case of failure, with an error string identical to the <code>error_message</code> field of the corresponding C and Fortran result types.</p> <p>The Fortran interface also offers you a \"shortcut\" that directly fetches your input parameter, halting your program with <code>STOP</code> on failure.</p> Fortran <pre><code>! Retrieves the input parameter with the given name, halting the program\n! on failure.\nfunction input_get(input, name) result(val)\nclass(input_t), intent(in)   :: input\ncharacter(len=*), intent(in) :: name\nreal(c_real) :: val\nend function\n</code></pre>"},{"location":"api/#reading-input-array-parameters","title":"Reading input array parameters","text":"<p>Skywalker offers you the ability to work with arrays of real-valued input parameters identified by a single name. These array parameters work the same as their scalar counterparts. Their memory is managed by Skywalker, so there's no need for you to perform any memory allocation.</p> <p>As with scalar input parameters, you can check to see whether an input array parameter exists within an ensemble member.</p> CC++Fortran <pre><code>// Returns true if an input array parameter with the given name exists within\n// the given input instance, false otherwise.\nbool sw_input_has_array(sw_input_t *input, const char* name);\n</code></pre> <pre><code>class Input final {\n...\n// Returns true if an input array parameter with the given name exists within\n// the given input instance, false otherwise.\nbool has_array(const std::string&amp; name) const;\n...\n};\n</code></pre> <pre><code>! Returns .true. if an input array parameter with the given name exists within\n! the given input instance, false otherwise.\nfunction input_has_array(input, name) result(has)\nclass(input_t), intent(in) :: input\ncharacter(len=*), intent(in)  :: name\nlogical(c_bool) :: has\nend function\n</code></pre> <p>The process of retrieving input array parameters works the same way as it does for scalar input parameters.</p> CC++Fortran <pre><code>// Retrieves the (array-valued) input parameter with the given name.\nsw_input_array_result_t sw_input_get_array(sw_input_t *input, const char *name);\n</code></pre> <pre><code>class Input final {\n...\n// Retrieves a (real-valued) array parameter with the given name, throwing an\n// exception if it doesn't exist.\nstd::vector&lt;Real&gt; get_array(const std::string&amp; name) const;\n};\n</code></pre> <pre><code>! Retrieves the input array parameter with the given name.\nfunction input_get_array_param(input, name) result(i_result)\nclass(input_t), intent(in)   :: input\ncharacter(len=*), intent(in) :: name\ntype(input_array_result_t) :: i_result\nend function\n</code></pre> <p>The C and Fortran interface define result types for fetching input array parameters.</p> CFortran <pre><code>typedef struct sw_input_array_result_t {\nsw_real_t *values;         // fetched values (if error_code == 0)\nsize_t size;               // number of values (if error_code == 0)\nint error_code;            // error code indicating success or failure\nconst char* error_message; // text description of error\n} sw_input_array_result_t;\n</code></pre> <pre><code>type :: input_array_result_t\nreal(c_real), dimension(:), pointer :: values ! fetched values (if error_code == 0)\ninteger(c_size_t)                   :: size   ! number of values (if error_code == 0)\ninteger(c_int)                      :: error_code    ! error code indicating success or failure\ncharacter(len=255)                  :: error_message ! text description of error\nend type input_array_result_t\n</code></pre> <p>As with scalar input parameters, the C++ interface throws a <code>skywalker::Exception</code> if it cannot retrieve a given input array parameter. And, as in the scalar case, the Fortran interface also defines a subroutine that tries to fetch an array parameter and halts with <code>STOP</code> on failure.</p> Fortran <pre><code>! Retrieves the input array parameter with the given name, halting on\n! failure.\nsubroutine input_get_array(input, name, values)\nclass(input_t), intent(in)   :: input\ncharacter(len=*), intent(in) :: name\nreal(c_real), allocatable, dimension(:), intent(inout) :: values\nend subroutine\n</code></pre> <p>If you use this subroutine, you must deallocate the <code>values</code> array when you're finished with it.</p>"},{"location":"api/#computing-output-parameters-from-input-parameters","title":"Computing output parameters from input parameters","text":"<p>This is where you do your thing. Nobody knows your job better than you! Remember that all input and output parameters are floating point numbers, so if your work uses integer inputs or outputs, you must perform all necessary type casting.</p>"},{"location":"api/#setting-output-parameters","title":"Setting output parameters","text":"<p>When you've computed an output value from one or more input values, you'll want to store that value by name in the ensemble member's output data. To do this, you can call a function to set the value of a named output parameter.</p> CC++Fortran <pre><code>// This function sets a quantity with the given name and value within the given\n// output instance. This operation cannot fail under normal circumstances.\nvoid sw_output_set(sw_output_t *output, const char *name, sw_real_t value);\n</code></pre> <pre><code>class Output final {\n...\n// Sets a (real-valued) parameter with the given name. This operation\n// cannot fail under normal circumstances.\nvoid set(const std::string&amp; name, Real value) const;\n...\n};\n</code></pre> <pre><code>! Sets a quantity with the given name and value within the given output\n! instance. This operation cannot fail under normal circumstances.\nsubroutine output_set(output, name, value)\nclass(output_t), intent(in)  :: output\ncharacter(len=*), intent(in) :: name\nreal(c_real), intent(in)     :: value\nend subroutine\n</code></pre> <p>The operation of setting an output parameter can't fail under normal circumstances (sufficient memory, good hardware, etc). Skywalker handles all the bookkeeping details.</p>"},{"location":"api/#setting-output-array-parameters","title":"Setting output array parameters","text":"<p>Output array parameters work the same way as input array parameters: they're just output values that share a common name. You can set an array-valued output parameter by calling the appropriate function or subroutine.</p> CC++Fortran <pre><code>// This function sets an array of quantities with the given name and values\n// within the given output instance. This operation cannot fail under normal\n// circumstances.\nvoid sw_output_set_array(sw_output_t *output, const char *name,\nconst sw_real_t *values, size_t size);\n</code></pre> <pre><code>class Output final {\n...\n// Sets (real-valued) parameters in an array with the given name. This\n// operation cannot fail under normal circumstances.\nvoid set(const std::string&amp; name, const std::vector&lt;Real&gt; &amp;values) const;\n...\n};\n</code></pre> <pre><code>! Sets an array of quantities with the given name and values to the given\n! output instance. This operation cannot fail under normal circumstances.\nsubroutine output_set_array(output, name, values)\nclass(output_t), intent(in)  :: output\ncharacter(len=*), intent(in) :: name\nreal(c_real), target, intent(in), dimension(:) :: values\nend subroutine\n</code></pre> <p>As with scalar output parameters, the operation of setting an output array parameter cannot fail under normal circumstances.</p>"},{"location":"api/#writing-ensemble-output","title":"Writing Ensemble Output","text":"<p>At the end of your program, you can call a function to write all your ensemble data to a Python module that be postprocessed.</p> CC++Fortran <pre><code>// Writes input and output data within the ensemble to a Python module stored\n// in the file with the given name.\nsw_write_result_t sw_ensemble_write(sw_ensemble_t *ensemble,\nconst char *module_filename);\n</code></pre> <pre><code>class Ensemble final {\n...\n// Writes input and output data within the ensemble to a Python module stored\n// in the file with the given name.\nvoid write(const std::string&amp; module_filename) const;\n...\n};\n</code></pre> <pre><code>! Writes input and output data within the ensemble to a Python module stored\n! in the file with the given name.\nfunction ensemble_write_module(ensemble, module_filename) result (w_result)\nclass(ensemble_t), intent(in) :: ensemble\ncharacter(len=*), intent(in)  :: module_filename\ntype(write_result_t) :: w_result\nend subroutine\n</code></pre> <p>Because it attempts to write a file, this operation can fail. The C and Fortran interfaces define a result type that can capture the information needed to handle this failure.</p> CFortran <pre><code>typedef struct sw_write_result_t {\nint error_code;            // error code indicating success or failure\nconst char* error_message; // text description of error\n} sw_write_result_t;\n</code></pre> <pre><code>type :: write_result_t\ninteger(c_int)     :: error_code    ! error code indicating success or failure\ncharacter(len=255) :: error_message ! text description of error\nend type write_result_t\n</code></pre> <p>As usual, the C++ interface throws a <code>skywalker::Exception</code> containing a string identical to the <code>error_message</code> field found in the corresponding C and Fortran result types. And, as usual, there is a Fortran subroutine that attempts to write the ensemble data to the given file and halts on failure.</p> Fortran <pre><code>! Writes input and output data within the ensemble to a Python module stored\n! in the file with the given name, halting on failure.\nsubroutine ensemble_write(ensemble, module_filename)\nclass(ensemble_t), intent(in) :: ensemble\ncharacter(len=*), intent(in)  :: module_filename\nend subroutine\n</code></pre>"},{"location":"api/#cleanup","title":"Cleanup","text":"<p>After you've written the Python module, you should free the resources your ensemble uses by destroying it. In C and Fortran, you can do this with a simple function call.</p> CFortran <pre><code>// Destroys an ensemble, freeing its allocated resources. Use this at the end\n// of your driver program, or when a fatal error has been encountered.\nvoid sw_ensemble_free(sw_ensemble_t *ensemble);\n</code></pre> <pre><code>! Destroys an ensemble, freeing all allocated resources.\nsubroutine ensemble_free(ensemble)\nclass(ensemble_t), intent(in) :: ensemble\nend subroutine\n</code></pre> <p>In C++, you can simply <code>delete</code> the <code>Ensemble</code> pointer you obtained by calling <code>skywalker::load_ensemble</code>, or you can use a smart pointer to store the ensemble.</p>"},{"location":"api/#miscellaneous","title":"Miscellaneous","text":"<p>In addition to the types and interfaces we've described, there are a few extra functions you might find handy in your Skywalker program.</p>"},{"location":"api/#printing-a-banner","title":"Printing a banner","text":"<p>You can write a banner to the standard error strstream (<code>stderr</code> in C and C++) with a call to the appropriate function.</p> CC++Fortran <pre><code>// Prints a banner containing Skywalker's version info to stderr.\nvoid sw_print_banner(void);\n</code></pre> <pre><code>namespace skywalker {\n...\n// Prints a banner containing Skywalker's version info to stderr.\nvoid print_banner() {\n...\n} // namespace skywalker\n</code></pre> <pre><code>! Prints a banner containing Skywalker's version info to stderr.\nsubroutine print_banner()\nend subroutine\n</code></pre> <p>This banner prints out the version of Skywalker used by your program. This can be helpful if you think you've encountered a bug in Skywalker, or if you're trying to use a newer feature of the library.</p>"},{"location":"api/#getting-the-ensembles-size","title":"Getting the ensemble's size","text":"<p>Sometimes it helps to know how many members an ensemble contains.</p> CC++Fortran <pre><code>// Returns the size of the given ensemble.\nsize_t sw_ensemble_size(sw_ensemble_t* ensemble);\n</code></pre> <pre><code>class Ensemble {\n...\n// Returns the size of the ensemble (number of members).\nsize_t size() const;\n...\n};\n</code></pre> <p>The ensemble's size is stored in the <code>size</code> field of the <code>ensemble_t</code> derived type.</p>"},{"location":"example/","title":"Example: Van der Waals Gas","text":"<p>The example in this section focuses on the Van der Waals gas law, a generalization of the ideal gas law that accurately describes many gases over a great range of temperatures, pressures, and volumes. The example has three parts.</p> <p>In this example, we use the Standard International (SI, also called mks) system of units. When we define a quantity, we denote its units in square brackets. For example, the mass of an object could be written as \\(m\\) [kg]. Quantities without units are followed by [-].</p> <p>The code for the example is available in the examples folder of the Skywalker source tree.</p> <p>We'll use Python to make a few plots along the way. We use Python 3 and the matplotlib library, which comes with many scientific Python packages like IPython. If you're not using one of those packages, you can usually install matplotlib with a command like the following:</p> <pre><code>pip3 install matplotlib\n</code></pre>"},{"location":"example/#ideal-gas","title":"Ideal gas","text":"<p>Recall that the ideal gas law relates the pressure, temperature, and volume of a gas through the equation of state</p> \\[ pV = \\nu R T \\] <p>where</p> <ul> <li>\\(p\\) is the gas pressure [Pa]</li> <li>\\(V\\) is the volume occupied by the gas [m\\(^3\\)]</li> <li>\\(\\nu\\) is the number of moles of gas contained in the volume \\(V\\) [-]</li> <li>\\(R\\) is the universal gas constant [J \\(\\cdot\\) K\\(^{-1} \\cdot\\) mol\\(^{-1}\\)]</li> <li>\\(T\\) is the temperature of the gas [K]</li> </ul> <p>Strictly speaking, the ideal gas law holds for gases whose molecules don't interact with one another. While this is not true for any known substance, it's a good approximation for gases whose molecules interact only weakly.</p>"},{"location":"example/#van-der-waals-gas","title":"Van der Waals gas","text":"<p>The equation of state for the van der Waals gas law is a refinement of the ideal gas law that attempts to model weak interactions between particles using a pair of parameters \\(a\\) and \\(b\\). The equation is</p> \\[ (p + a/V^2)(V - b) = \\nu RT \\] <p>where \\(a\\) represents the effects of cohesive forces within a molecule, and \\(b\\) represents effects of molecules having a finite size. Clearly, when \\(a=b=0\\), this equation reverts to the ideal gas law.</p> <p>The Van der Waals approximation is a significant improvement on the ideal gas law, and can be used to study various phenomena. Our discussion follows that in Chapter IV of Thermodynamics, by Enrico Fermi, Dover Publications, NY (1936).</p>"},{"location":"example/#part-1-plotting-isotherms","title":"Part 1: Plotting Isotherms","text":"<p>An isotherm is a thermodynamic process in which the temperature remains the same throughout. Isothermal processes are important in any setting in which smaller physical systems interact with a heat reservoir at a given temperature. They are conveniently expressed using PV diagrams, which are just XY plots with the volume \\(V\\) on the \\(x\\) axis and the pressure \\(p\\) on the \\(y\\) axis.</p>"},{"location":"example/#ideal-gas_1","title":"Ideal gas","text":"<p>We can construct an isotherm curve for an ideal gas by writing the pressure \\(p\\) as a function of \\(V\\) and \\(T\\) for a single mole of gas (\\(\\nu = 1\\)):</p> \\[ p(V, T) = \\frac{RT}{V} \\] <p>Let's write a simple Skywalker program that takes \\(V\\) and \\(T\\) as input and computes \\(p\\) as output. Our program will read the following input file, named <code>ideal_gas_isotherms</code>, which constructs an ensemble of \\((V, T)\\) pairs, with \\(V \\in [5^{-5}, 1^{-3}]\\) m\\({^3}\\) and \\(T\\) assuming the values 273 K, 373 K, 473 K, 573 K, and 673 K.</p> ideal_gas_isotherms.yaml <pre><code>input:\n  lattice:\n    V: [5.0e-5, 1.0e-3, 1.0e-6]  # [m^3]\n    T: [273, 373, 473, 573, 673] # [K]\n</code></pre> <p>Here's our program:</p> CC++Fortran <pre><code>// isotherms.c\n#include &lt;skywalker.h&gt;\n\n// This function retrieves the value with the given name from the given\n// input, exiting on failure.\nsw_real_t get_value(sw_input_t *input, const char *name) {\nsw_input_result_t in_result = sw_input_get(input, name);\nif (in_result.error_code != SW_SUCCESS) {\nfprintf(stderr, \"isotherms_c: %s\", in_result.error_message);\nexit(-1);\n}\nreturn in_result.value;\n}\n\n// Here's the main function.\nint main(int argc, char **argv) {\nconst char *input_file = \"ideal_gas_isotherms.yaml\";\n\n// Load the ensemble. Any error encountered is fatal.\nprintf(\"isotherms_c: Loading ensemble from %s...\\n\", input_file);\nsw_ensemble_result_t load_result = sw_load_ensemble(input_file, NULL);\nif (load_result.error_code != SW_SUCCESS) {\nfprintf(stderr, \"isotherms_c: %s\", load_result.error_message);\nexit(-1);\n}\n\nsw_ensemble_t *ensemble = load_result.ensemble;\nprintf(\"isotherms_c: found %zd ensemble members.\\n\", sw_ensemble_size(ensemble));\n\n// Iterate over all members of the ensemble.\nsw_input_t *input;\nsw_output_t *output;\nwhile (sw_ensemble_next(ensemble, &amp;input, &amp;output)) {\n// Fetch (V, T) from the member's input.\nsw_real_t V = get_value(input, \"V\"); // gas (molar) volume [m3]\nsw_real_t T = get_value(input, \"T\"); // gas temperature [K]\n\n// Compute p(V, T).\nstatic const sw_real_t R = 8.31446261815324;\nsw_real_t p = R * T / V;\n\n// Stash the computed pressure in the member's output.\nsw_output_set(output, \"p\", p);\n}\n\n// Write out a Python module.\nconst char *output_file = \"ideal_gas_isotherms_c.py\";\nprintf(\"isotherms_c: Writing data to %s...\\n\", output_file);\nsw_write_result_t w_result = sw_ensemble_write(ensemble, output_file);\nif (w_result.error_code != SW_SUCCESS) {\nfprintf(stderr, \"isotherms_c: %s\\n\", w_result.error_message);\nexit(-1);\n}\n\n// Clean up.\nsw_ensemble_free(ensemble);\n}\n</code></pre> <pre><code>// isotherms.cpp\n#include &lt;skywalker.hpp&gt;\n\nint main(int argc, char **argv) {\nstd::string input_file = \"ideal_gas_isotherms.yaml\";\n\n// Load the ensemble. Any error encountered is fatal.\nstd::cout &lt;&lt; \"isotherms_cpp: Loading ensemble from \" &lt;&lt; input_file &lt;&lt; \"...\\n\";\nskywalker::Ensemble *ensemble = nullptr;\ntry {\nensemble = skywalker::load_ensemble(input_file);\n} catch (skywalker::Exception &amp;e) {\nstd::cerr &lt;&lt; \"isotherms_cpp: \" &lt;&lt; e.what() &lt;&lt; std::endl;\nexit(-1);\n}\nstd::cout &lt;&lt; \"isotherms_cpp: found \" &lt;&lt; ensemble-&gt;size() &lt;&lt; \" ensemble members.\\n\";\n\n// Iterate over all members of the ensemble.\ntry {\nensemble-&gt;process([](const skywalker::Input &amp;input,\nskywalker::Output &amp;output) {\n// Fetch inputs.\nskywalker::Real V = input.get(\"V\"); // gas (molar) volume [m3]\nskywalker::Real T = input.get(\"T\"); // gas temperature [K]\n\n// Compute p(V, T).\nstatic const skywalker::Real R = 8.31446261815324;\nskywalker::Real p = R * T / V;\n\n// Stash the computed pressure in the member's output.\noutput.set(\"p\", p);\n});\n} catch (skywalker::Exception &amp;e) {\nstd::cerr &lt;&lt; \"isotherms_cpp: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\nexit(-1);\n}\n\n// Write out a Python module.\nstd::string output_file = \"ideal_gas_isotherms_cpp.py\";\nstd::cout &lt;&lt; \"isotherms_cpp: Writing data to \" &lt;&lt; output_file &lt;&lt; \"...\\n\";\ntry {\nensemble-&gt;write(output_file);\n} catch (skywalker::Exception &amp;e) {\nstd::cerr &lt;&lt; \"isotherms_cpp: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\nexit(-1);\n}\n\n// Clean up.\ndelete ensemble;\n}\n</code></pre> <pre><code>! isotherms.F90\nprogram isotherms\nuse iso_c_binding, only: c_float, c_double\nuse skywalker\nimplicit none\n\n! Universal gas constant\nreal(swp), parameter     :: R = 8.31446261815324_swp\n\ncharacter(len=255)      :: input_file, output_file\ntype(ensemble_result_t) :: load_result\ntype(ensemble_t)        :: ensemble\ntype(input_t)           :: input\ntype(output_t)          :: output\nreal(swp)               :: V, T, p, a, b\n\ninput_file = \"ideal_gas_isotherms.yaml\"\n\n! Load the ensemble. Any error encountered is fatal.\nprint *, \"isotherms_f90: Loading ensemble from \", trim(input_file), \"...\"\nload_result = load_ensemble(trim(input_file))\nif (load_result%error_code /= SW_SUCCESS) then\n    print *, \"isotherms_f90: \", trim(load_result%error_message)\nstop\n  end if\n\nensemble = load_result%ensemble\nprint *, \"isotherms_f90: found \", ensemble%size, \" ensemble members.\"\n\n! Iterate over all members of the ensemble.\ndo while (ensemble%next(input, output))\n! Fetch inputs.\nV = input%get(\"V\") ! gas (molar) volume [m3]\nT = input%get(\"T\") ! gas temperature [K]\n\n! Compute p(V, T).\np = R * T / V\n\n! Stash the computed pressure in the member's output.\ncall output%set(\"p\", p);\nend do\n\n! Write out a Python module.\noutput_file = \"ideal_gas_isotherms_f90.py\"\nprint *, \"isotherms_f90: Writing data to \", output_file, \"...\"\ncall ensemble%write(output_file)\n\n! Clean up.\ncall ensemble%free();\nend program\n</code></pre> <p>Click through the different tabs for the C, C++, and Fortran versions of the program. You can see that they're very similar. Here's what's going on:</p> <ol> <li>An ensemble is loaded with a <code>load_ensemble</code> function. If the attempt to    load the ensemble fails, the program halts.</li> <li>The members of the ensemble are processed one by one. In the C and Fortran    programs, this happens in a <code>while</code>/<code>do while</code> loop, in which a call to    <code>sw_ensemble_next</code> or <code>ensemble%next</code> associates the <code>input</code> and <code>output</code>    variables with a specific ensemble member. In C++, this loop is hidden inside    a call to <code>ensemble-&gt;process</code>, which accepts a lambda function whose    arguments are the properly associated <code>input</code> and <code>output</code> variables for each    member. Inside this loop:<ol> <li>the gas volume \\(V\\) and temperature \\(T\\) are extracted from the <code>input</code>    variable for the current ensemble member</li> <li>the gas pressure \\(p\\) is computed from \\(V\\) and \\(T\\)</li> <li>the computed pressure \\(p\\) is stored in the <code>output</code> variable for the    current ensemble member</li> </ol> </li> <li>After every ensemble member has been processed in Step 2, a Python module    containing all input and output data for the ensemble is written.</li> <li>The ensemble is deleted with an appropriate function call or command.</li> </ol> <p>For a more detailed explanation of any of these steps, see the API section.</p> <p>If you like, copy and paste any version of the program into a text editor, save it, and build it, linking it against <code>libskywalker.a</code> or <code>libskywalker_f90.a</code> as needed. Then run it in a directory containing <code>ideal_gas_isotherms.yaml</code>, and check to see that an appropriate <code>.py</code> file appears.</p> <p>Here's a plot of the resulting isotherms:</p> <p></p> <p>If you want to generate this plot for yourself, run the plot_isotherms.py script in the <code>examples/</code> folder of the repo on the appropriate <code>.py</code> file, leaving out the <code>.py</code> suffix. E.g.</p> <pre><code>python3 plot_isotherms.py ideal_gas_isotherms_c\n</code></pre>"},{"location":"example/#van-der-waals-gases","title":"Van der Waals gases","text":"<p>Now that we've successfully used Skywalker to plot the isotherms of an ideal gas at several temperatures, we can generalize our program(s) to handle Van der Waals gases. The expression for the gas pressure is</p> \\[ p = \\frac{RT}{V - b} - \\frac{a}{V^2} \\] <p>First, we must add the two parameters \\(a\\) and \\(b\\) as input. Here's a YAML input file that sets these parameters for diatomic nitrogen gas:</p> n2_gas_isotherms.yaml <pre><code>input:\n  fixed:\n    a: 0.137                     # [Pa m6/mol2]\n    b: 3.87e-5                   # [m3/mol]\n  lattice:\n    V: [5.0e-5, 1.0e-3, 1.0e-6]  # [m^3]\n    T: [273, 373, 473, 573, 673] # [K]\n</code></pre> <p>And here's one for carbon dioxide:</p> co2_gas_isotherms.yaml <pre><code>input:\n  fixed:\n    a: 0.3658                    # [J m3/mol2]\n    b: 4.29e-5                   # [m3/mol]\n  lattice:\n    V: [5.0e-5, 1.0e-3, 1.0e-6]  # [m3]\n    T: [273, 373, 473, 573, 673] # [K]\n</code></pre> <p>Now we must modify our programs to include these input parameters in the calculation of the gas pressure. Here are code snippets that implement these changes:</p> CC++Fortran <p>Replace lines 38-40 with <pre><code>    // Fetch Van der Waals parameters if they're present.\nsw_real_t a = 0.0, b = 0.0;\nif (sw_input_has(input, \"a\")) {\na = get_value(input, \"a\");\n}\nif (sw_input_has(input, \"b\")) {\nb = get_value(input, \"b\");\n}\n\n// Compute p(V, T).\nstatic const sw_real_t R = 8.31446261815324;\nsw_real_t p = R * T / (V - b) - a/(V*V);\n</code></pre></p> <p>Replace lines 26-28 with <pre><code>      // Fetch Van der Waals parameters if they're present.\nskywalker::Real a = 0.0, b = 0.0;\nif (input.has(\"a\")) {\na = input.get(\"a\");\n}\nif (input.has(\"b\")) {\nb = input.get(\"b\");\n}\n\n// Compute p(V, T).\nstatic const skywalker::Real R = 8.31446261815324;\nskywalker::Real p = R * T / (V - b) - a/(V*V);\n</code></pre></p> <p>Declare <code>real(swp)</code> variables <code>a</code> and <code>b</code>, and replace lines 39-40 with <pre><code>    ! Fetch Van der Waals parameters if they're present.\na = 0.0_swp\nb = 0.0_swp\nif (input%has(\"a\")) a = input%get(\"a\")\nif (input%has(\"b\")) b = input%get(\"b\")\n\n! Compute p(V, T).\np = R * T / (V - b) - a/(V**2)\n</code></pre></p> <p>With these changes, the program can now build the ensembles indicated in the <code>n2_gas_isotherms.yaml</code> and <code>co2_gas_isotherms.yaml</code> files. Here are all of the resulting plots (including our ideal gas for comparison):</p> Ideal gasN2 gasCO2 gas <p></p> <p></p> <p></p>"},{"location":"example/#exercises","title":"Exercises","text":"<ol> <li>Experiment with different values of \\(a\\) and \\(b\\). Are there values that    trigger interesting or surprising behavior? Try to interpret these values    physically.</li> </ol>"},{"location":"example/#part-2-determining-the-saturation-vapor-pressure-in-carbon-dioxide","title":"Part 2: Determining the Saturation Vapor Pressure in Carbon Dioxide","text":"<p>You may be curious about what's happening with the blue curve representing the isotherm for \\(T = 273\\) K for carbon dioxide. If you follow the curve starting from the right, it represents a compression process for the gas at a constant temperature. Somewhere around \\(V = 2 \\times 10^{-4}\\) m\\(^3\\), something funny happens: the gas pressure decreases under compression. This simply doesn't happen in reality. What's going on?</p> <p>What's going on is a phase change: carbon dioxide condenses to liquid form under these conditions. The gas is no longer in a homogeneous state, and the Van der Waals equation of state isn't satisfied for the gas/liquid mixture. Rather, the pressure (called the saturation vapor pressure) remains constant alongside the temperature over the course of the phase change. One way to understand this is that under a phase change, the system alters its binding energy but not its kinetic energy. The pressure in a Van der Waals gas depends only on its kinetic energy (because it assumes that the particles interact only weakly), so it remains constant.</p> <p>In other words, the saturation vapor pressure is a horizontal line \\(p(V) = p_s\\) over the course of the phase change. It looks like this:</p> <p></p> <p>Suppose we wanted to modify our program to make use of these ideas. Our objective is to find the value of the saturation pressure, or the height of the horizontal line in the vicinity of the phase change. One might think that we must use the Clausius-Clapeyron equation, which involves the latent heat of evaporation and the specific volumes of the gas and liquid phases. However, the shape of the isotherm in question actually gives us enough geometric information to use an iterative approach that does a decent job of estimating the saturation vapor pressure using Maxwell's equal area rule.</p>"},{"location":"example/#approximating-the-saturation-vapor-pressure-numerically","title":"Approximating the saturation vapor pressure numerically","text":"<p>We don't have a curve \\(p(V)\\) to work with in our calculation of \\(V_s\\)--we only have a discrete set of points with volumes \\(\\{V_i\\}\\) and pressures \\(\\{p_i\\}\\). Let \\(i_1\\) be the index of the first point along the (horizontal) phase change curve, and let \\(i_2\\) be the index of the last point along this curve. These two points have the same pressure, which is the saturation vapor pressure. How do we determine them?</p> <p>Suppose we start the points at two distinctive locations and move them around till they have equal pressure. For example, we can set \\(i_1\\) to the point at the trough of the Van der Waals isotherm, and \\(i_2\\) to the local peak to the right of this trough. Then we know that our initial value of \\(i_1\\) is too large, and that our initial value of \\(i_2\\) is too small.</p> <p>We can now devise an iterative scheme that moves \\(i_1\\) and \\(i_2\\) apart until the difference in their pressures hits a minimum.</p> <pre><code> pdiff := abs(p(i2) - p(i1))\n Do forever\n   # Trying moving i1 to the left, reversing if we hit a higher\n   # pressure difference.\n   prev_i1 := i1\n   i1 := i1 - 1\n   p21 := abs(p(i2) - p(i1))\n   if p21 &lt; pdiff\n     pdiff := p21\n   else\n     i1 := i1 + 1\n\n   # Trying moving i2 to the right.\n   prev_i2 := i2\n   i2 := i2 + 1\n   p21 := abs(p(i2) - p(i1))\n   if p21 &lt; pdiff\n     pdiff := p21\n   else\n     i2 := i2 - 1\n\n   # If we didn't move either point, we're finished.\n   if i1 = prev_i1 and i2 = prev_i2\n     break\n</code></pre> <p>Once we've found a plausible saturation vapor pressure, we can increase or decrease it until the areas bounded by the original curve and the flat saturation pressure sum to zero. These areas are described by the integral of the pressure over the range of volumes in question, so what we're looking for is</p> \\[   \\int_{V_1}^{V_2} (p - p_s) \\texttt{d}V = 0, \\] <p>or</p> \\[   \\int_{V_1}^{V_s} (p - p_s) \\texttt{d}V + \\int_{V_s}^{V_2} (p - p_s) \\texttt{d}V = 0, \\] <p>where \\(p_s = p(V_s)\\) is the saturation vapor pressure and \\(V_1\\) and \\(V_2\\) are, respectively, the minimum and maximum volumes at which \\(p(V) = p_s\\) in the original Van der Waals pressure curves. These integrals can be approximated using a simple quadrature rule such as the midpoint rule.</p>"},{"location":"example/#exercises_1","title":"Exercises","text":"<ol> <li>Try to implement this iterative scheme to compute the saturation vapor    pressure for the above isotherm. (Hint: use an input that specifies a    single temperature.) Extra credit: can you add a setting to your program    that specifies whether or not to compute the saturation vapor pressure?    You can read about settings in the Input Format and API    sections.</li> <li>Can you find the critical point for carbon dioxide by exploring various    Van der Waals isotherms? How do you know when you've found it?</li> </ol>"},{"location":"input/","title":"Input Format (YAML)","text":"<p>A Skywalker program accepts a YAML file as input. YAML is a simple and expressive language for describing data in a portable format. It offers all of the features of Fortran namelists and more, and it can be used in programs written in any language.</p> <p>Skywalker extracts information from specific variables in your YAML input file. For simplicity, we refer to variables at the top level of a YAML file as blocks, because they resemble block sections in other file formats. Here's an example of a YAML file containing blocks <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>:</p> <pre><code>a: This block is just a string\n\nb:\n  description: this block is a set of keys and values\n  key1: value1        # (like this!)\n  key2: 112           # (and this!)\n  key3: 3.14159265357 # (and this!)\n\nc: [1, 2, 3, 4, 5] # this block is an array of integers\n\nd: # this block is the \u0455ame array as c, expressed differently\n  - 1\n  - 2\n  - 3\n  - 4\n  - 5\n</code></pre> <p>As you can see above, lists of values are indicated by comma-separated values surrounded by braces, or a sequence of values prepended by hyphens. Notice also that YAML ignores anything starting with a <code>#</code> character, which allows you to annotate YAML files with comments.</p>"},{"location":"input/#skywalker-yaml-input","title":"Skywalker YAML Input","text":"<p>Skywalker looks for the following information in an input file, each of which belongs in its own block:</p> <ul> <li>an optional settings block that conveys information from the user to a   Skywalker program</li> <li>an input block that defines the members of the ensemble.</li> </ul> <p>Here's an example of a Skywalker input file used to test an aerosol parameterization that appears in two different scientific codes:</p> <pre><code># Computes the rate of binary nucleation as a function of relative humidity [-]\n# and temperature [K]\n\ndriver1: # settings for driver1\n  nucleation_method: 2\n  pbl_method: 0\n\ndriver2: # settings for driver2\n  name: mer07_veh02_wang08_nuc_1box\n  newnuc_method_user_choice: 2\n  pbl_nuc_wang2008_user_choice: 0\n\ninput:\n  fixed:\n    c_h2so4: 5e8 # [#/cc]\n    planetary_boundary_layer_height: 1100\n    height: 500\n    xi_nh3: 0\n  lattice:\n    relative_humidity: [0.01, 1.00, 0.01]\n    temperature: [230.15, 300.15, 1]\n</code></pre> <p>Below, we describe the structure of each of these blocks, and give examples. Skywalker parses the input YAML file for you, so there's no need to worry about types, comments, or any of the details of the YAML format.</p> <p>These blocks can appear in any order within a YAML file. A Skywalker program ignores all blocks aside from settings and <code>input</code> blocks.</p>"},{"location":"input/#settings","title":"Settings","text":"<p>A Skywalker program may need information about how to configure itself, in addition to the information about the ensembles it constructs. If it does, it can specify the name of a block to search for \"settings\". For example, the Skywalker input file in the first section of this page has two settings blocks:</p> <ul> <li><code>driver1</code>, which is needed by one Skywalker program</li> <li><code>driver2</code>, which is needed by a different Skywalker program</li> </ul> <p>The ability to tell Skywalker where to look for settings allows you to run several different programs with the same input, and compare their results. This is an invaluable capability for cross validating scientific codes.</p> <p>Notice the structure of the <code>driver1</code> and <code>driver2</code> settings blocks. They consist of simple named variables, each with a single value. Skywalker settings are always interpreted as strings, so if your program needs an integer or floating point value to configure itself, it must convert the relevant setting to the correct type.</p> <p>Settings blocks are entirely optional and can be omitted if you don't need them.</p>"},{"location":"input/#input","title":"Input","text":"<p>Skywalker looks for parameter values in a <code>input</code> block. There are three types of parameters that define an ensemble:</p> <ol> <li><code>fixed</code>: A fixed parameter assumes a single value for every member of    an ensemble.</li> <li><code>lattice</code>: A lattice parameter is a parameter that assumes several values    over different ensemble members and is combined with all other lattice    parameters to form a lattice spanned by the ensemble. When Skywalker    constructs an ensemble, it takes the outer product of all values for    lattice parameters. In everyday language, this means that there exists an    ensemble member for every possible combination of all lattice parameters.    For example, a lattice of 3 parameters each assuming 10 values creates an    ensemble of \\(10\\times10\\times10 = 1000\\) members. The order in which parameter    values are specified is not specified or controllable.</li> <li><code>enumerated</code>: An enumerated parmeter adopts a specific set of values in    tandem with all other enumerated parameters in lockstep, to construct    ensemble members that have these values. The first ensemble member assumes    the first specified value of each parameter, a second member assumes the    second value of each, and so on. All ensemble parameters must have the same    number of values. For example, in an ensemble consisting a set of enumerated    parameters with 1000 members, every parameter must assume 1000 values.</li> </ol> <p>Look at the <code>input</code> block in the above example. There are 8 parameters: 4 fixed parameters and 4 lattice parameters. The fixed parameters assume a single value, and the lattice parameters assume several values.</p> <p>You can easily construct an ensemble using a combination of lattice and enumerated parameters. To figure out the number of members in such an ensemble, simply multiply the number of members in the generated lattice by the number of enumerated values in any of the ensemble parameters.</p>"},{"location":"input/#lists-of-parameter-values-and-uniform-spacing","title":"Lists of Parameter Values and Uniform Spacing","text":"<p>There are a few ways to specify multiple values for a parameter. The simplest way is to list the values exhaustively. For example, if we want to study the behavior of our binary nucleation parameterization between temperatures of 230.15 K and 300.15 K, in increments of 1 K, we can write</p> <pre><code>input:\n  ...\n  temperature: [230.15, 231.15, 232.15, 233.15, ..., 298.15, 299.15, 300.15]\n  ...\n</code></pre> <p>where we have replaced several terms with ellipsis for brevity. This is simple but cumbersome, especially since we are using a uniform step size. A much easier way to do the same thing is to use the form of the <code>temperature</code> parameter in the above example, which uses a 3-value list to specify the same set of values:</p> <pre><code>input:\n  ...\n  temperature: [230.15, 300.15, 1]\n  ...\n</code></pre> <p>This reads: \"the <code>temperature</code> parameter assumes values from 230.15 to 300.15, including the endpoints, in uniform steps of 1.\"</p> <p>How does Skywalker know this isn't a list containing the temperatures 230.15 K, 300.15 K, and 1 K? It uses a set of simple rules to determine how to interpret these values.</p> <p>A list with values \\(\\[v_1, v_2, v_3\\]\\) that satisfies the following properties is expanded into a uniformly spaced set of values between \\(v_1\\) and \\(v_2\\) with spacing \\(v_3\\):</p> <ul> <li>\\(v_1 &lt; v_2\\)</li> <li>\\(0 &lt; v_3 &lt; v_2\\) or \\(v_2 &lt; 0\\) and \\(0 &lt; v_3 &lt; (v_2 - v_1)/2\\)</li> </ul> <p>All other lists are interpreted as lists containing 3 values.</p> <p>These rules handle most cases of interest, but there remain some sequences that suggest expan\u0455ion but that Skywalker does not expand.</p>"},{"location":"input/#examples","title":"Examples","text":"<p>For example, the list <code>[-11, 1, 2]</code> could be interpreted as the uniformly-spaced set of values <code>[-11, -9, -7, -5, -3, -1, 1]</code>, but since \\(2 &gt; 1\\) and \\(1 &gt; 0\\), Skywalker doesn't expand it.</p> <p>Some other examples:</p> <ul> <li>The list <code>[0, 1, 0.1]</code> expands to <code>[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]</code>.</li> <li>The list <code>[-2, 0, 0.2]</code> is not expanded.</li> <li>The list <code>[-2, 1, 0.25]</code> expands to <code>[-2, -1.75, -1.5, -1.25, -1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1]</code>.</li> <li>The list <code>[-10, -1, 1]</code> expands to <code>[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1]</code>.</li> <li>The list <code>[-11, 1, 1]</code> is not expanded.</li> <li>The list <code>[-11, 1, 2]</code> is not expanded.</li> <li>The list <code>[-7, 2, 1]</code> expands to <code>[-7, -6, -5, -4, -3, -2, -1, 0, 1, 2]</code>.</li> </ul> <p>Because this expan\u0455ion feature is intended as a convenience, you can always explicitly perform the expan\u0455ion yourself when you create an input file.</p>"},{"location":"input/#logarithmic-spacing","title":"Logarithmic Spacing","text":"<p>Sometimes a parameter varies over several orders of magnitude, making it inconvenient to specify uniformly-spaced values. For example, chemical reactions can exhibit different behaviors over large ranges of number concentrations in their reactants. For these situations, Skywalker offers an elegant solution that allows you to define the values for a such a parameter on a logarithmic scale. Simply \"take the log of\" the entry for your parameter:</p> <pre><code>input:\n  ...\n  log10(c_h2so4): [10, 12, 0.05]\n  ...\n</code></pre> <p>The above list assigns values to the parameter <code>c_h2so4</code> between \\(10^{10}\\) and \\(10^{12}\\), using \\((12 - 10)/0.05 = 40\\) uniformly-spaced points on a logarithmic scale.</p> <p>You can use this logarithmic option for parameters with explicitly listed values as well, but it's most u\u0455eful when combined with the uniform spacing above.</p>"},{"location":"input/#array-valued-parameters","title":"Array-Valued Parameters","text":"<p>Occasionally, it's useful to use a single parameter name for a collection of values. For example, the concentrations in a miscible fluid can be considered the components of a single variable, as long as their ordering is well defined.</p> <p>Here, Skywalker takes advantage of the flexibility in the YAML format. Suppose you have a variable <code>densities</code> representing the various densities in a fluid mixture, and that there are 3 components. Here's how you would specify 4 different configurations of the fluid's concentrations:</p> <pre><code>input:\n  fixed:\n    densities: [1e-5, 1e-9, 1e-7]\n  ...\n</code></pre> <p>In addition, you can also define lattice parameters that are arrays, such as: <pre><code>input:\n  lattice:\n    current_gas_mix_ratios: [[0.1, 0.3, 0.6], [0, 0.4, 0.4], [0.2, 0.8, 0], [0.5, 0.25, 0.25]]\n</code></pre></p> <p>Here, we have used two sets of braces (a \"list of lists\") to indicate that the parameter <code>current_gas_mix_ratios</code> assumes 4 values, each of which is a list of 3 numbers.</p> <p>This is a very powerful syntax, but it comes with \u0455ome caveats:</p> <ul> <li>You can't use logarithmic spacing options with array parameters</li> <li>Skywalker makes no attempt to verify that all values in a list of array   parameters have the same length</li> </ul> <p>The three-parameter uniform spacing option is also available to array parameters:</p> <pre><code>input:\n  ...\n  lattice:\n    wet_geo_mean_diameter: [[0.001, 0.002, 0.003],[0.004, 0.005, 0.009], [0.001, 0.001, 0.002]]\n  ...\n</code></pre> <p>In the input above, the <code>wet_geo_mean_diameter</code> parameter assumes an array value with uniform spacing for each ensemble. The array values start at <code>[0.001, 0.002, 0.003]</code> and go to <code>[0.004, 0.005, 0.009]</code>, incrementing each individual array entry by <code>[0.001, 0.001, 0.002]</code> for each ensemble. The interpretation of the values as a uniform spacing list is the same as above for a scalar list:</p> <ul> <li>The list contains 3 arrays</li> <li>Each value in the first list is less than the corresponding value in the second list</li> <li>Each value in the third list is less than the corresponding value in the second list</li> </ul> <p>All other lists are interpreted as lists containing 3 lists.</p> <p>Use array-valued parameters with caution.</p>"},{"location":"installation/","title":"Installation","text":"<p>We've tried to make Skywalker as easy as possible to use with your current software. To build it, you need</p> <ul> <li>CMake v3.10+</li> <li>GNU Make</li> <li>Reliable C and C++ compilers (like GCC and Clang)</li> <li>A decent Fortran compiler (like GFortran or Intel's <code>ifort</code>)</li> </ul> <p>You can also build Skywalker on Windows. It has been tested with Visual Studio 2022 Community Edition with the Intel oneAPI Fortran Class\u0456c (<code>ifort</code>) compiler. Your mileage may vary if you use different versions of Visual Studio or a different Fortran compiler.</p>"},{"location":"installation/#clone-the-repository","title":"Clone the Repository","text":"<p>First, go get the source code at GitHub:</p> SSHHTTPS <pre><code>git clone git@github.com:eagles-project/skywalker.git\n</code></pre> <pre><code>git clone https://github.com/eagles-project/skywalker.git\n</code></pre> <p>This places a <code>skywalker</code> folder into your current path. If you're using Visual Studio, just use your Git workflow to clone the repository.</p>"},{"location":"installation/#configure-skywalker","title":"Configure Skywalker","text":"<p>Skywalker uses CMake as its build system. CMake accepts a few options that specify how Skywalker should be built. Here are the most important options for you to consider.</p> <ul> <li><code>CMAKE_INSTALL_PREFIX</code> sets the path to which the Skywalker C, C++, and   Fortran headers/module and libraries are installed. This is often something   like <code>/usr/local</code> by default.</li> <li><code>CMAKE_BUILD_TYPE</code> controls whether optimization is on (<code>Release</code>) or whether   the build is instrumented for a debugger (<code>Debug</code>).</li> <li><code>SKYWALKER_PRECISION</code> can be set to <code>single</code> or <code>double</code> (default) to control   the precision of floating point numbers.</li> <li><code>CMAKE_C_COMPILER</code> sets the C compiler that is used to build Skywalker.   Usually, the default compiler is fine, but if you want to use an MPI-capable   compiler or a specific vendor compiler, you can specify it with this option.</li> <li><code>ENABLE_FORTRAN</code>, when set to <code>ON</code> (its default value), builds Fortran support   for Skywalker. You can set this to <code>OFF</code> if you don't need Fortran.</li> <li><code>CMAKE_Fortran_COMPILER</code> sets the Fortran compiler that is used to build   Skywalker's Fortran interface.</li> </ul> Linux/MacWindows <p>From the top-level <code>skywalker</code> directory, create a \"build\" directory (e.g. <code>build</code>). This is where you'll configure and build Skywalker. For example, to configure a debuggable build of Skywalker that uses double precision, do the following:</p> <pre><code>mkdir build\ncd build\ncmake -DCMAKE_INSTALL_PREFIX=/path/to/install \\\n      -DCMAKE_BUILD_TYPE=Debug \\\n      -DSKYWALKER_PRECISION=double \\\n      ..\n</code></pre> <p>This creates a set of <code>Makefile</code>s in your build directory. Now you're ready to build.</p> <p>Visual Studio gets its settings from <code>CMakeSettings.json</code> in the top-level source directory.</p>"},{"location":"installation/#build-test-and-install-skywalker","title":"Build, Test, and Install Skywalker","text":"Linux/MacWindows <p>To build skywalker, make sure you're in your build directory and type</p> <pre><code>make -j\n</code></pre> <p>If this process succeeds, you can run the tests and examples included with Skywalker by typing</p> <pre><code>make test\n</code></pre> <p>If you're using Linux, you can also run Skywalker's tests through Valgrind to check for memory corruptions and leaks with</p> <pre><code>make memcheck\n</code></pre> <p>(but be prepared to wait a while for the tests to finish).</p> <p>You should see several tests run (and hopefully pass!). Now, to install Skywalker to the path you specified with <code>CMAKE_INSTALL_PREFIX</code>, type</p> <pre><code>make install\n</code></pre> <p>You should be able to use the Build and Test workflows in Visual Studio to build, test, and install Skywalker.</p> <p>The installation process produces the following artifacts, which you can use to build your own Skywalker programs:</p> <ul> <li><code>PREFIX/lib/libskywalker_&lt;precision&gt;.a</code>, a library you can use with a C or C++   Skywalker program.</li> <li><code>PREFIX/include/skywalker.h</code>, a C header file that provides Skywalker's C   interface.</li> <li><code>PREFIX/include/skywalker.hpp</code>, a C++ header file that provides Skywalker's   C++ interface.</li> <li><code>PREFIX/share/skywalker.cmake</code>, a CMake file that includes installation   information for Skywalker, plus a function called <code>add_skywalker_driver</code> you   can use to build your own driver programs.</li> </ul> <p>When <code>ENABLE_FORTRAN</code> is set to <code>ON</code>, you get additional Fortran artifacts: * <code>PREFIX/lib/libskywalker_f90_&lt;precision&gt;.a</code>, a library you can use with a   Fortran Skywalker program. * <code>PREFIX/include/skywalker.mod</code>, a Fortran 90 module header file that provides   Skywalker's Fortran interface.</p> <p>On Windows, the library files have a <code>.lib</code> suffix instead of <code>.a</code>.</p> <p>Here, <code>PREFIX</code> stands for the path you passed to <code>CMAKE_INSTALL_PREFIX</code>. These files are all you need to build Skywalker programs.</p>"},{"location":"installation/#try-it-out","title":"Try It Out!","text":"<p>At this point, you're ready to start using Skywalker. Look at the Quick Start section to get started.</p>"},{"location":"output/","title":"Output Format (Python)","text":"<p>A Skywalker program writes all of its data (input parameters and output values) to a text file containing a Python module. The data in the Python module is structured in a regular way for easy use by postprocessing scripts. The module contains two Python variables:</p> <ol> <li><code>input</code>, an object whose fields list all of the input parameters specified in    the YAML input file, in ascending lexicographic order by name</li> <li><code>output</code>, an object whose fields list all of the output parameters    corresponding to the input parameters, in ascending lexicographic order by    name</li> <li><code>settings</code> (if settings are present), an object whose fields list all of the    driver-specific settings used to process the ensemble. All settings fields    are strings, and the settings are sorted in ascending lexicographic order by    name.</li> </ol> <p>Consider the <code>input</code> block from the example input file in the Input Format section:</p> <pre><code>my_settings:\n  method = quadrature\n\ninput:\n  lattice:\n    relative_humidity: [0.01, 1.00, 0.01]\n    temperature: [230.15, 300.15, 1]\n  fixed:\n    c_h2so4: 5e8 # [#/cc]\n    planetary_boundary_layer_height: 1100\n    height: 500\n    xi_nh3: 0\n</code></pre> <p>With this input, Skywalker constructs an ensemble whose members assume all possible combinations of its <code>lattice</code> parameters. There are 100 values for <code>relative_humidity</code>, 71 values for <code>temperature</code>, and a single value for all other parameters. So there are \\(100 \\times 71 = 7100\\) members in the resulting lattice ensemble.</p> <p>Suppose our program generates output variables <code>nucleation_rate</code> and <code>nucleation_threshold</code>, both of which depend on some or all of the input parameters. Here's how the resulting Python module might look.</p> <pre><code># This file was automatically generated by skywalker.\n\nfrom math import nan as nan\n\n# Object is just a dynamic container that stores input/output data.\nclass Object(object):\n    pass\n\n# Settings are stored here.\nsettings = Object()\nsettings.method = 'quadrature'\n\n# Input is stored here.\ninput = Object()\ninput.relative_humidity = [0.01, 0.02, 0.03, ..., 0.98, 0.99, 1.00, ]\ninput.temperature = [230.15, 230.15, 230.15, ..., 300.15, 300.15, 300.15, ]\ninput.c_h2so4 = [5e8, 5e8, 5e8, ..., 5e8, 5e8, 5e8, ]\ninput.planetary_boundary_layer_height = [1100, 1100, 1100, ..., 1100, 1100, 1100, ]\ninput.height = [500, 500, 500, ..., 500, 500, 500, ]\n\n# Output data is stored here.\noutput = Object()\noutput.nucleation_rate = [1.56031e+06, 4.00182e+06, 6.14731e+06, ..., 2.75652e-08, 3.8792e-08, 5.44561e-08, ]\noutput.nucleation_threshold = [2.52217e+09, 2.37766e+09, 2.24821e+09, ..., 9.00622e+08, 8.85519e+08, 8.70748e+08, ]\n</code></pre> <p>We've used ellipsis to omit unnecessary detail. The <code>Object</code> type is just a simple trick to allow us to dynamically create fields for the <code>settings</code>, <code>input</code>, and <code>output</code> variables.</p> <p>The important thing here is that all input and output lists in this module have 7100 values, and these values all appear in the same order. The first value in each list belongs to the first member of the ensemble, the second value to the second member, and so on, up to the last value in each list, which belongs to the last ensemble member.</p> <p>This allows you to write postprocessing logic that can easily associate input and output variables. You can easily write a postprocessor to do sensitivity analysis, parameter estimation, or comparisons of two or more different algorithms or codes.</p> <p>You can even write a conversion utility that imports the Python module and writes it to another format. For an example of this, take a look at the py2ncl program included with Skywalker. <code>py2ncl</code> converts Skywalker output to a text file that can be used with legacy NCL programs. (The latest version of NCL is adopting Python as its language.)</p>"},{"location":"output/#nans","title":"NaNs","text":"<p>Sometimes a Skywalker program emits a NaN, either as the result of pathological numeric arithmetic or as an indicator that the value is undefined. In this case, the value is written using Python's <code>nan</code> representation. This ensures a faithful translation for all data, no matter what the circumstance.</p>"},{"location":"output/#array-valued-outputs","title":"Array-Valued Outputs","text":"<p>Just as you can store multiple values in a single input array parameter, you can write outputs with multiple values stored in an array. And just as input array parameters are indicated with two sets of braces in a YAML input file, output array values are similarly indicated with two sets of braces, even for ensembles having only a single member. The syntax is easy and intuitive, mostly because YAML and Python use the same format for defining lists.</p> <p>Skywalker doesn't impose any structure on array-valued outputs. For example, it's possible to write arrays with different sizes to a single output variable. Therefore, your program must write array-valued outputs in the most sensible way for your work.</p>"},{"location":"quick_start/","title":"Quick Start","text":"<p>Once you've successfully installed Skywalker, it's time to write your first Skywalker program. Sometimes we refer to such a program as a driver, since it's really just a way to run an algorithm or parameterization that we want to study.</p> <p>Let's get started.</p>"},{"location":"quick_start/#step-1-design-an-experiment","title":"Step 1: Design an Experiment","text":"<p>For simplicity, we are going to study a function of two variables</p> \\[ f(x, y) = y \\sin(x) - x \\cos(y) \\] <p>over the domain \\([-2\\pi, 2\\pi]\\times[\u22122\\pi, 2\\pi]\\). Our input parameters are \\(x\\) and \\(y\\), and our output variable is \\(f\\). We will sample points on a uniform grid of evenly-spaced \\(x\\) and \\(y\\) values.</p> <p>Suppose we want to sample \\(f\\) at 100 \\(x\\) values and 100 \\(y\\) values, tracing out the surface it represents above the euclidean plane. Here's a YAML file that sets up the calculation of \\(f\\) on these \\((x, y)\\) points:</p> surface.yaml <pre><code>input:\n  lattice:\n    x: [-6.2831853, 6.2831853, 0.0628]\n    y: [-6.2831853, 6.2831853, 0.0628]\n</code></pre> <p>Line 2 indicates that all values of \\(x\\) are combined with all values of \\(y\\). Lines 3 and 4 define 100 uniformly-spaced values between \\(\u22122\\pi\\) and \\(2\\pi\\) for \\(x\\) and \\(y\\). You can find detailed explanations of all these things in the Input Format (YAML) section.</p> <p>This YAML input file reflects the design of our experiment. Now we just need a Skywalker program that computes \\(f\\) at each of the points we've specified.</p>"},{"location":"quick_start/#step-2-write-a-skywalker-program","title":"Step 2: Write a Skywalker Program","text":"<p>A Skywalker program creates an ensemble of complete sets of inputs (in this case, the point \\((x, y)\\) in \\(\\mathbb{R}^2\\)). Each point represents a member of the ensemble. The program loops over each ensemble members \\((x, y)\\) and computes the output \\(f\\) for it. Finally, it writes all of its ensemble data (all values of \\(x\\), \\(y\\), and \\(f\\)) to a Python module that can be used for postprocessing. The data in the module is ordered in such a way that each output is associated with its inputs.</p> <p>Here's a program that does all of these things, written in C, C++, and Fortran. Pick your favorite language, paste the corresponding code into a text editor, and save it to a file with the indicated name.</p> C (surface.c)C++ (surface.cpp)Fortran (surface.F90) <pre><code>#include &lt;skywalker.h&gt;\n#include &lt;math.h&gt;\n\nint main(int argc, char **argv) {\n// Specify the name of the input file.\nconst char *input_file = \"surface.yaml\";\n\n// Load the ensemble, exiting if the operation fails.\nsw_ensemble_result_t load_result = sw_load_ensemble(input_file, NULL);\nif (load_result.error_code != SW_SUCCESS) {\nfprintf(stderr, \"Error: %s\", load_result.error_message);\nexit(-1);\n}\n\n// Iterate over all members of the ensemble.\nsw_ensemble_t *ensemble = load_result.ensemble;\nsw_input_t *input;\nsw_output_t *output;\nwhile (sw_ensemble_next(ensemble, &amp;input, &amp;output)) {\n// Fetch input values.\nsw_input_result_t result = sw_input_get(input, \"x\");\nif (result.error_code != SW_SUCCESS) {\nfprintf(stderr, \"Error: %s\", load_result.error_message);\nexit(-1);\n}\nsw_real_t x = result.value;\nresult = sw_input_get(input, \"y\");\nif (result.error_code != SW_SUCCESS) {\nfprintf(stderr, \"Error: %s\", load_result.error_message);\nexit(-1);\n}\nsw_real_t y = result.value;\n\n// Compute f(x, y).\nsw_real_t f = y * sin(x) - x * cos(y);\n\n// Store f as an output variable.\nsw_output_set(output, \"f\", f);\n}\n\n// Write a Python module containing the input/output data.\nconst char *output_file = \"surface.py\";\nsw_write_result_t w_result = sw_ensemble_write(ensemble, output_file);\nif (w_result.error_code != SW_SUCCESS) {\nfprintf(stderr, \"Error: %s\", load_result.error_message);\nexit(-1);\n}\n\n// Clean up.\nsw_ensemble_free(ensemble);\n\nreturn 0;\n}\n</code></pre> <pre><code>#include &lt;skywalker.hpp&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char **argv) {\n// Specify the name of the input file.\nstd::string input_file = \"surface.yaml\";\n\n// Load the ensemble, exiting if the operation fails.\nskywalker::Ensemble *ensemble = nullptr;\ntry {\nensemble = skywalker::load_ensemble(input_file);\n\n// Iterate over all members of the ensemble. We define a lambda function\n// that operates on the input and output variables for each member.\nensemble-&gt;process([](const skywalker::Input &amp;input,\nskywalker::Output &amp;output) {\n// Fetch input values.\nskywalker::Real x = input.get(\"x\");\nskywalker::Real y = input.get(\"y\");\n\n// Compute f(x, y).\nskywalker::Real f = y * std::sin(x) - x * std::cos(y);\n\n// Store f as an output variable.\noutput.set(\"f\", f);\n});\n\n// Write a Python module containing the input/output data.\nstd::string output_file = \"surface.py\";\nensemble-&gt;write(output_file);\n\n// Clean up.\ndelete ensemble;\n} catch (skywalker::Exception&amp; e) {\nstd::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\nexit(-1);\n}\n\nreturn 0;\n}\n</code></pre> <pre><code>program surface\nuse skywalker\nimplicit none\n\ncharacter(len=255)      :: input_file, output_file\ntype(ensemble_result_t) :: load_result\ntype(ensemble_t)        :: ensemble\ntype(input_t)           :: input\ntype(output_t)          :: output\nreal(swp)               :: x, y, f\n\n! Specify the name of the input file.\ninput_file = \"surface.yaml\"\n\n! Load the ensemble, exiting if the operation fails.\nload_result = load_ensemble(trim(input_file))\nif (load_result%error_code /= SW_SUCCESS) then\n    print *, \"Error: \", trim(load_result%error_message)\nstop\n  end if\n\n! Iterate over all members of the ensemble.\nensemble = load_result%ensemble\ndo while (ensemble%next(input, output))\n! Fetch inputs.\nx = input%get(\"x\")\ny = input%get(\"y\")\n\n! Compute f(x, y).\nf = y * sin(x) - x * cos(y)\n\n! Store f as an output variable.\ncall output%set(\"f\", f);\nend do\n\n! Write out a Python module.\noutput_file = \"surface.py\"\ncall ensemble%write(output_file)\n\n! Clean up.\ncall ensemble%free();\nend program\n</code></pre> <p>The API section discusses each of the elements in this program. For now, let's just try to build it and run it.</p>"},{"location":"quick_start/#step-3-build-the-program","title":"Step 3: Build the Program","text":"<p>Everyone has their own setup for building programs, so let's keep it simple: we'll compile the program and link it against the appropriate Skywalker library (or libraries) in one step:</p> CC++Fortran <pre><code>cc surface.c -I/path/to/include -L/path/to/lib -lskywalker_double -o surface\n</code></pre> <pre><code>c++ surface.cpp -std=c++11 -I/path/to/include -L/path/to/lib -lskywalker_double -o surface\n</code></pre> <pre><code>gfortran surface.F90 -I/path/to/include -L/path/to/lib -lskywalker_f90_double -lskywalker_double -o surface\n</code></pre> <p>If you use a different compiler, substitute it above. A few things to note:</p> <ul> <li> <p>The C++ Skywalker program uses lambda functions, which requires at least   C++11.</p> </li> <li> <p>The <code>-I</code> flags above indicate the location of the Skywalker headers   (<code>skywalker.h</code>, <code>skywalker.hpp</code>) and modules (<code>skywalker.mod</code>) you installed   in the Installation section. So if you set Skywalker's   <code>CMAKE_INSTALL_PREFIX</code> to <code>/usr/local</code>, you would use <code>-I/usr/local/include</code>.</p> </li> <li> <p>Likewise, the <code>-L</code> flags tell the linker where to find the Skywalker   libraries. If your <code>CMAKE_INSTALL_PREFIX</code> is <code>/usr/local</code>, indicate this with   <code>-L/usr/local/lib</code>.</p> </li> <li> <p>The <code>-l</code> parameter indicates the library to link your program against. C and   C++ programs must be linked against <code>libskywalker_double.a</code>, while Fortran   programs must additionally use <code>libskywalker_f90_double.a</code>. If you've   configured Skywalker to use single precision floating point numbers with   <code>-DSKYWALKER_PRECISION=single</code>, replace <code>double</code> with <code>single</code>.</p> </li> </ul> <p>If all goes well, you'll end up with a <code>surface</code> executable.</p>"},{"location":"quick_start/#step-4-run-the-experiment","title":"Step 4: Run the Experiment","text":"<p>Now it's time to see the program in action. Make sure your <code>surface</code> executable is in the same directory as your <code>surface.yaml</code> input file, and run it without arguments:</p> <pre><code>./surface\n</code></pre> <p>Hopefully, the program runs to completion, generating a <code>surface.py</code> text file containing the data. You can open up this file in an editor to see how it looks. The format of this file is described here.</p>"},{"location":"quick_start/#step-5-analyze-the-results","title":"Step 5: Analyze the Results","text":"<p>Here's a simple Python 3 program you can run in the same directory as your <code>surface.py</code> file to generate a surface plot of \\(f(x, y)\\) over the domain \\([-2\\pi, 2\\pi] \\times [-2\\pi, 2\\pi]\\).</p> plot_surface.py <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Extract data from surface.py.\nimport surface\nx = np.array(surface.input.x)\ny = np.array(surface.input.y)\nf = np.array(surface.output.f)\n\n# Plot the contours of f(x, y).\nplt.tricontour(x, y, f)\nplt.colorbar()\n\n# Display the plot.\nplt.show()\n</code></pre> <p>The script uses matplotlib, which you can often install with a command like</p> <pre><code>pip3 install matplotlib\n</code></pre> <p>Run the script to see the plot.</p> <pre><code>python3 plot_surface.py\n</code></pre> <p>Here's how it looks:</p> <p></p> <p>That's it. Congratulations--you've successfully used Skywalker to sample a multivariate function over regularly spaced intervals. If you like, you can continue through the rest of the documentation to learn how things work. You can also take a look at a more involved example if that's your style.</p>"}]}